{"posts":[{"title":"Anaconda的使用","text":"1. 使用anaconda创建虚拟环境1conda create -n 环境名 python=3.8(python版本) 2. 切换环境1conda activate 环境名 3. 查看已经创建的虚拟环境1conda env list 4. 安装包1conda install 包名 5. 查看当前环境中已经安装的包1conda list 6. 删除环境和该环境下所有的包1conda remove --name myenv --all","link":"/blog/2024/06/07/Anaconda%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"CSS笔记","text":"1. BFC1.1 什么是BFC 1.2 开启BFC能解决什么问题 元素开启BFC后，其子元素不会再产生margin塌陷问题 元素开启BFC后，自己不会被其他浮动元素所覆盖 元素开启BFC后，就算其子元素浮动，元素自身高度也不会塌陷 1.3 如何开启BFC 根元素html自动开启BFC 浮动元素 绝对定位、固定定位的元素 行内块元素inline-block 表格单元格： table、thead 、 tbody 、 tfoot 、 th、td、tr、 caption overflow 的值不为 visible 的块元素 伸缩项目（父元素为伸缩容器） 多列容器 column-span 为 all的元素（即使该元素没有包裹在多列容器中） display 的值，设置为 flow-root 2. CSS中隐藏页面元素的6种方式及其区别2.1 display: none业务代码中最常用来隐藏页面元素的方法。它可以将元素在页面中彻底消失，而元素本身所占据的位置，会被其他元素占据，这就会导致浏览器进行重排和重绘；并且隐藏后，元素本身绑定的事件不会触发，也没有消失的过渡效果。总结：元素不可见，不占据页面空间，无法响应点击事件，页面会发生重排和重绘 2.2 visibility: hidden它不仅可以隐藏页面元素，而且元素本身会存在页面中，即占据位置，只是它是处于一个不可见的状态而已；在页面中占据位置，那就不会发生重排，但是会发生重绘；元素本身的绑定的事件也不会触发。总结：元素不可见，占据页面空间，无法响应点击事件，页面会发生重绘 2.3 opacity: 0将元素的透明度设为0之后，元素是可以达到隐藏效果的，它不会引发浏览器重排，但是它一般是会引起重绘的；由于元素是存在于页面之上的，所以元素本身绑定的事件是可以被触发的，但是被它遮挡的元素是不能触发点击事件的。总结：改变元素透明度从而实现隐藏效果，占据页面空间，可以响应点击事件，页面会发生重绘 2.4 position: absolute这其实是一个讨巧的方法，就是通过将元素移出页面从而达到隐藏的效果。业务中其实是用它来做其他的事，例如：定义一个canvas标签，进入页面进行绘图，然后拿到绘制的图片进行展示，这时就可以将canvas容器设置为页面之外，不影响整个页面的渲染。总结：通过将元素移出页面从而实现隐藏效果，不影响页面布局，无法响应点击事件 2.5 宽高设置为0然后来说将元素的宽高都设为0的方式，当把元素的宽高都设为0了，这个元素自然就被“隐藏”了。用此种方法需将width、height、margin、padding、border等影响元素盒模型的属性都为设为0；如果元素内含有子元素内容，还需要设置元素的overflow: hidden来隐藏子元素；宽高都没有了自然就无法响应点击事件了。总结：通过将宽高等盒模型属性均设为0从而达到隐藏效果，不占据页面空间，无法响应点击事件 2.6 clip-pathclip-path属性使用裁剪方式创建元素的可显示区域，区域内的部分显示，区域外的隐藏。 123div { clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);} polygon()为定义一个多边形。如：clip-path: polygon(17px 182px, 109px 23px, 199px 182px);就表示为定义了一个三角形，语法里面一个逗号多边形的一个顶点，有三个逗号则为三角形，依次类推（交叉可能不闭合就不会有多边形）。这里将其全被设为0，则表示围不成一个多边形，也就没有元素节点，从而就达到了隐藏的效果；其在页面中是有空间的，但是无法响应点击事件的。总结：通过裁减创建元素从而达到隐藏效果，占据页面空间，无法响应点击事件 3. CSS水平垂直居中9种方法3.1 父子元素宽高未知3.1.1 第一种：table-cell使用表格样式 12345678.parent { display: table-cell; text-align: center; vertical-align: middle;}.children { display: inline-block;} 3.1.2 第二种：flex布局（两种办法）只设置父元素 12345.parent { display: flex; justify-content: center; align-items: center;} 同时设置父子元素 1234567.parent { display: flex;}.children { align-self: center; margin: auto;} 3.1.3 第三种：absolute+transform123456789.parent { position: relative;}.children { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} 3.1.4 第四种：absolute + margin: auto1234567891011.parent { position: relative;}.children { position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;} 3.1.5 第五种：Grid 布局1234567.parent { display: grid;}.children { align-self: center; justify-self: center;} 3.1.6 第六种：直接使用 table（改变结构实现，和第一条类似）123456789&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 123456.parent { text-align: center;}.children { display: inline-block;} 3.2 子元素宽高已知（假设子元素宽高为 200px）3.2.1 第七种：absolute + calc12345678.parent { position: relative;}.children { position: absolute; top: calc(50% - 100px); left: calc(50% - 100px);} 3.2.2 第八种：absolute + 负 margin12345678910.parent { position: relative;}.children { position: absolute; top: 50%; left: 50%; margin-top: -100px; margin-left: -100px;} 3.3 父元素高度已知（假设为 400px），子元素宽高未知3.3.1 第九种：text-align + vertical-align123456789.parent { text-align: center; line-height: 400px;}.children { display: inline-block; vertical-align: middle; line-height: initial;} 4. 对盒模型的理解盒模型有两种：标准盒模型、IE盒模型 盒模型从内到外由四部分组成：content、padding、border、margin标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同： 标准盒模型的width和height属性的范围只包含content IE盒模型的width和height属性包含了border、padding、content 可以通过box-sizing属性来改变元素的盒模型： box-sizing: content-box 表示标准盒模型（默认值） box-sizing: border-box 表示IE盒模型（怪异盒模型） 5. link标签会阻塞渲染吗link标签并不会阻塞DOM解析，但是会阻塞DOM的渲染。 浏览器并行解析生成DOM Tree和CSS Tree，两者都解析完毕，才会生成render Tree，页面才会渲染。 6. Flex:1表示什么flex属性是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。 flex: 1表示flex: 1 1 0%。 第一个参数：flex-grow定义项目放大比例，默认值是0，即如果存在剩余空间，也不放大。 第二个参数：flex-shrink定义了项目的缩小比例，默认是1，即如果空间不足，该项目将缩小。 第三个参数：flex-basis指定了flex元素在主轴方向上的初始大小。当一个元素同时被设置了 flex-basis (除值为 auto 外) 和 width (或者在 flex-direction: column 情况下设置了height) , flex-basis 具有更高的优先级。","link":"/blog/2024/04/21/CSS%E7%AC%94%E8%AE%B0/"},{"title":"HTML笔记","text":"1. href和src的区别1.1 请求资源类型不同 href是Hypertext Reference的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a 在请求 src 资源时会将其指向的资源下载并应用到文档中，常用的有script，img 、iframe 1.2 作用结果不同 href 用于在当前文档和引用资源之间确立联系 src 用于替换当前内容 1.3 浏览器解析方式不同 若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。 当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 2. link和@import的区别 link是XHTML标签，除了能够加载CSS，还可以定义RSS等其他事务；而@import属于CSS范畴，只可以加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后再加载。 link是XHTML标签，无兼容问题；@import则是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM改变样式；而@import不支持。 3. 行内元素和块级元素有哪些 行内元素：&lt;a&gt; &lt;span&gt; &lt;img&gt; &lt;input&gt; &lt;select&gt; &lt;strong&gt; 块级元素：&lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;dl&gt; &lt;p&gt; &lt;h1&gt;~&lt;h6&gt;","link":"/blog/2024/04/21/HTML%E7%AC%94%E8%AE%B0/"},{"title":"JS数组有哪些常用原生方法？哪些能改变数组本身？","text":"1. 数组和字符串的转换方法toString 不改变原数组 12const arr = [1, 2, 3]console.log(arr.toString()); // 1,2,3 join 不改变原数组join(str) 数组转字符串，接收一个参数，默认为逗号分隔符。 1234const arr = [1, 2, 3]console.log(arr) // [1, 2, 3]console.log(arr.join()) // 1,2,3console.log(arr.join(':')) // 1:2:3 2. 数组尾部操作方法pop 改变原数组pop() 删除并返回数组最后一个元素。 123const arr = [1, 2, 3]console.log(arr) // [1, 2, 3]console.log(arr.pop()) // 3 push 改变原数组push() 向数组末尾添加一个或多个元素，并返回新的长度。 123const arr = [1, 2]console.log(arr.push(3)) // 3console.log(arr) // [1, 2, 3] 3. 数组首部操作方法shift 改变原数组shift() 删除并返回数组第一个元素。 123const arr = [1, 2, 3]console.log(arr) // [1, 2, 3]console.log(arr.shift()) // 1 unshift 改变原数组unshift() 向数组首部添加一个或多个元素，并返回新的长度。 123const arr = [1, 2]console.log(arr.unshift(3)) // 3console.log(arr) // [3, 1, 2] 4. 排序方法reverse 改变原数组reverse() 颠倒数组中元素顺序。 123const arr = [1, 2, 3, 4]console.log(arr.reverse()) // [4, 3, 2, 1]console.log(arr) // [4, 3, 2, 1] sort 改变原数组sort() 对数组进行排序。 123const arr = [2, 4, 3, 1]console.log(arr.sort()) // [1, 2, 3, 4]console.log(arr) // [1, 2, 3, 4] sort() 按照数组元素数值的大小对数字进行排序，是按照字符编码的顺序进行排序，那怎么样根据元素数值大小进行排序呢？ 12345const arr = [2, 4, 3, 1]const arr1 = [...arr].sort((a, b) =&gt; a - b)const arr2 = [...arr].sort((a, b) =&gt; b - a)console.log(arr1) // [1, 2, 3, 4]console.log(arr2) // [4, 3, 2, 1] 5. 数组连接的方法concat 不改变原数组arr1.concat(arr2) 连接两个或多个数组，返回一个新的数组。 12345const arr1 = [1, 2, 3]const arr2 = [4, 5]const newArr = arr1.concat(arr2)console.log(newArr) // [1, 2, 3, 4, 5]console.log(arr1) // [1, 2, 3] 6. 数组截取方法slice 不改变原数组slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。正数索引从0开始，负数索引从-1开始。 12345const arr = [1, 2, 3, 4, 5]console.log(arr.slice(1)) // [2, 3, 4, 5]console.log(arr.slice(1, -2)) // [2, 3]console.log(arr.slice(-3, -1)) // [3, 4]console.log(arr) // [1, 2, 3, 4, 5] 7. 数组插入方法splice 改变原数组12345const months = ['Jan', 'March', 'April', 'June'];months.splice(1, 0, 'Feb'); // 在索引1处插入元素console.log(months); // [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, 'May'); // 在索引4处替换1个元素console.log(months); // [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;] 8. 数组索引方法indexOf lastIndexOf 不改变原数组两个方法都是返回要查找的项所在数组中首次出现的位置，没找到的话就返回-1。arr.indexOf(item, start) 从数组的开头开始向后寻找。arr.lastIndexOf(item, start) 从数组的末尾开始向前查找。 1234const arr = [2, 4, 1, 9, 1, 2]console.log(arr.indexOf(2)) // 0console.log(arr.lastIndexOf(1)) // 4console.log(arr.indexOf(3)) // -1 9. 总结 改变原数组的方法 不改变原数组的方法 pop toString push join shift concat unshift slice reverse indexOf sort lastIndexOf splice","link":"/blog/2024/04/22/JS%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%9F%E5%93%AA%E4%BA%9B%E8%83%BD%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E6%9C%AC%E8%BA%AB%EF%BC%9F/"},{"title":"JavaScript笔记","text":"1. JavaScript如何实现继承1.1 原型链继承原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。 123456789function Parent() { this.name = 'parent1'; this.play = [1, 2, 3]}function Child() { this.type = 'child2';}Child.prototype = new Parent();console.log(new Child()) 1.2 盗用构造函数继承12345678910111213141516function Parent(){ this.name = 'parent';}Parent.prototype.getName = function () { return this.name;}function Child(){ Parent.call(this); this.type = 'child'}let child = new Child();console.log(child); // 没问题console.log(child.getName()); // 会报错 可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法 相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法。 1.3 组合继承组合继承则将前两种方式继承起来。 12345678910111213141516171819202122232425function Parent () { this.name = 'parent'; this.play = [1, 2, 3];}Parent.prototype.getName = function () { return this.name;}function Child() { // 第二次调用 Parent() Parent.call(this); this.type = 'child';}// 第一次调用 Parent()Child.prototype = new Parent();// 手动挂上构造器，指向自己的构造函数Child.prototype.constructor = Child;var s1 = new Child();var s2 = new Child();s1.play.push(4);console.log(s1.play, s2.play); // 不互相影响console.log(s1.getName()); // 正常输出'parent'console.log(s2.getName()); // 正常输出'parent' 1.4 原型式继承这里主要借助Object.create方法实现普通对象的继承。 1234567891011121314151617181920let parent = { name: &quot;parent&quot;, friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;], getName: function() { return this.name; }};let person1 = Object.create(parent);person1.name = &quot;tom&quot;;person1.friends.push(&quot;jerry&quot;);let person2 = Object.create(parent);person2.friends.push(&quot;lucy&quot;);console.log(person1.name); // tomconsole.log(person1.name === person1.getName()); // trueconsole.log(person2.name); // parentconsole.log(person1.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]console.log(person2.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;] 这种继承方式的缺点也很明显，因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能。 1.5 寄生式继承寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法。 1234567891011121314151617181920let parent = { name: &quot;parent&quot;, friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;], getName: function() { return this.name; }};function clone(original) { let clone = Object.create(original); clone.getFriends = function() { return this.friends; }; return clone;}let person = clone(parent);console.log(person.getName()); // parentconsole.log(person.getFriends()); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;] 其优缺点也很明显，跟上面讲的原型式继承一样。 1.6 寄生式组合继承寄生组合式继承，借助解决普通对象的继承问题的Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式。 12345678910111213141516171819202122232425262728function clone (parent, child) { // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程 child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;}function Parent() { this.name = 'parent'; this.play = [1, 2, 3];}Parent.prototype.getName = function () { return this.name;}function Child() { Parent.call(this); this.friends = 'child';}clone(Parent, Child);Child.prototype.getFriends = function () { return this.friends;}let person = new Child();console.log(person); // Child {name: 'parent', play: Array(3), friends: 'child'}console.log(person.getName()); // parentconsole.log(person.getFriends()); // child 2. object.assign和扩展运算符的区别 两者都是浅拷贝，确切地说是对于对象实例的拷贝属于浅拷贝 对象合并，数组合并，Object.assign、connat的性能会比展开运算符“…”的性能高 Object.assign会触发Proxy/Object.definedProperty的set方法，展开运算符“…”不会触发 合并对象、数组的时候，展开运算符放在前面的性能比放在后面的性能高 3. Web Storage API3.1 sessionStoragesessionStorage为每一个给定的源（origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。 仅为会话存储数据，这意味着数据将一直存储到浏览器（或选项卡）关闭。 数据永远不会被传输到服务器。 存储限额大于 cookie（最大 5MB）。 3.2 localStoragelocalStorage做同样的事情，但即使浏览器关闭并重新打开也仍然存在。 存储的数据没有过期日期，只能通过 JavaScript、清除浏览器缓存或本地存储的数据来清除。 存储限额是两者之间的最大值。 4. WebSocket WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() { if (&quot;WebSocket&quot; in window) { alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() { // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); }; ws.onmessage = function (evt) { var received_msg = evt.data; alert(&quot;数据已接收...&quot;); }; ws.onclose = function() { // 关闭 websocket alert(&quot;连接已关闭...&quot;); }; } else { // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 5. 前端本地存储的4种方法5.1 cookie 用于浏览器和server的通讯 可设置失效时间，默认是浏览器关闭后失效 存放数据大小为4K左右 每次都会携带在HTTP头中，如果使用Cookie保存过多数据会带来性能的问题 cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据 5.2 localStorage 除非被清除，否则永久保存 存放数据大小一般为5MB 仅在客户端（即浏览器）中保存，不参与和服务器的通信 浏览器可以设置是否可以访问数据，如果设置不允许会访问失败 兼容IE8以上浏览器 只能存储字符串类型，需要转成字符串存储 5.3 sessionStorage 仅在当前会话下有效，关闭tab页面或浏览器后被清除 存放数据大小一般为5MB 仅在客户端（即浏览器）中保存，不参与和服务器的通信 5.4 indexDBMDN官网：IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。IndexedDB主要用来客户端存储大量数据而生的，我们都知道cookie、localstorage等存储方式都有存储大小限制。如果数据量很大，且都需要客户端存储时，那么就可以使用IndexedDB数据库。 使用场景： 数据可视化等界面，大量数据，每次请求会消耗很大性能。 即时聊天工具，大量消息需要存在本地。 其它存储方式容量不满足时，不得已使用IndexedDB 6. 函数柯里化函数柯里化指的是一种将使用多个参数的一个函数，转换成一系列使用一个参数的函数的技术。对于已经柯里化后的 _fn 函数来说， 当接收的参数数量与原函数的形参数量相同时，执行原函数； 当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数。 123456789101112131415161718192021222324252627282930function curry(fn, args) { // 获取函数需要的参数长度 let length = fn.length; args = args || []; return function() { let subArgs = [...args, ... arguments]; // 判断参数的长度是否已经满足函数所需参数的长度 if (subArgs.length &gt;= length) { // 如果满足，执行函数 return fn.apply(this, subArgs); } else { // 如果不满足，递归返回柯里化函数，等待参数的传入 return curry.call(this, fn, subArgs); } }}// 需要柯里化的函数function multiFn(a, b, c) { return a * b * c;}// multi是柯里化之后的函数let multi = curry(multiFn);console.log(multi(2)(3)(4)); // 24console.log(multi(2, 3, 4));console.log(multi(2)(3, 4));console.log(multi(2, 3)(4)); 1234// ES6实现function curry(fn, ...args) { return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);} 7. 利用 Promise.race 和 Promise.all 解决网络过快 loading 闪烁问题终极解决方式是将 Promise.all() 和 Promise.race() 搭配使用。先利用Promise.race()约束请求在超时时间内返回时就直接渲染，否则就固定展示一段时间的loading动画再渲染数据。即请求如果没有在 500ms 内返回则固定展示 1500ms 的loading。 1234567891011121314151617181920212223242526272829303132333435function resolvePromise(time) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(`在${time}ms后返回成功Promise`); }, time) });}function rejectPromise(time) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(new Error(`在${time}ms后返回失败Promise`)); }, time) });}function reqData() { // 记录请求的状态 const axiosRequest = getData(); Promise.race([axiosRequest, rejectPromise(500)]).then((res) =&gt; { // 成功意味着请求在固定时间内返回 }).catch((err) =&gt; { // 超时，整体变成onrejected，展示loading loading.value = true; console.log(err.message); Promise.all([axiosRequest, resolvePromise(1500)]).then((res) =&gt; { // Promise.all执行结果返回的数组顺序是按传入顺序决定的 console.log(res[0]); }).catch((err) =&gt; { console.log(err); }).finally(() =&gt; { lodaing.value = false; }) })} 8. 链式调用1234567891011121314151617181920class N { constructor(value) { this.value = value || 0; } add(num) { this.value += num; return this; } minus(num) { this.value -= num; return this; } get() { console.log(this.value); return this.value; }}const n = new N(2);n.add(198).minus(100).get(); // 100 9. 手写Promise1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const PENDING = 'pending';const FULLFILLED = 'fullfilled';const REJECTED = 'rejected';function MyPromise(fn) { this.state = PENDING; this.value = null; const that = this; this.resolvedCallbacks = []; this.rejectedCallabcks = []; function resolve(val) { if (that.state === PENDING) { that.state = FULLFILLED; that.value = val; that.resolvedCallbacks.map((cb) =&gt; { cb(that.value); }) } } function reject(val) { if (that.state === PENDING) { that.state = REJECTED; that.value = val; that.rejectedCallabcks.map((cb) =&gt; { cb(that.value); }) } } try { fn(resolve, reject); } catch (err) { reject(err); }}MyPromise.prototype.then = function (onFullfilled, onRejected) { // 保存前一个promise的this const self = this; return new MyPromise((resolve, reject) =&gt; { // 封装前一个promise成功时执行的函数 let fullfilled = () =&gt; { try { const result = onFullfilled(self.value); return result instanceof MyPromise ? result.then(resolve, reject) : resolve(result); } catch (err) { reject(err); } } // 封装前一个promise失败时执行的函数 let rejected = () =&gt; { try { const result = onReject(self.reason); return result instanceof MyPromise ? result.then(resolve, reject) : reject(result); } catch (err) { reject(err) } } switch (self.state) { case PENDING: self.resolvedCallbacks.push(fullfilled); self.rejectedCallabcks.push(rejected); break; case FULLFILLED: fullfilled(); break; case REJECTED: rejectted(); break; } })}let p = new MyPromise((resolve, reject) =&gt; { resolve('OK');})p.then((res) =&gt; { console.log(res, 'OK');}, (err) =&gt; { console.log(err, 'fail');}) 10. 执行上下文的创建创建执行上下文有明确的几个步骤： 确定this，即我们所熟知的this绑定。 创建词法环境组件。 创建变量环境组件。 10.1 确定this在全局执行上下文中，this 总是指向全局对象。例如：浏览器环境下 this 指向 window 对象。在函数执行上下文中，this 的值取决于函数的调用方式，如果被一个对象调用，那么 this 指向这个对象。否则（在浏览器中） this 一般指向全局对象 window 或者 undefined （严格模式）。 10.2 创建词法环境组件词法环境是一个包含标识符变量映射的结构，这里的标识符表示变量（函数）的名称，变量是对实际对象（包括函数类型对象）或原始值的引用。如：var name = 1;。标识符是 name，引用是 1。词法环境由环境记录器与对外部环境的引用两个组件组成： 环境记录器用于存储当前环境中的变量和函数声明的实际位置。 外部环境的引用对应着可以访问的其它外部环境。（所以子作用域可以访问父作用域） 10.3 创建变量环境变量环境与词法环境十分相似。在 ES6 中，词法环境和变量环境的明显不同就是前者被用来存储函数声明和变量（let/const）的绑定，而后者只用来存储 var 变量的绑定。 11. bind函数与call和apply的区别11.1 bindbind方法和call很相似，第一个参数也是this指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）。bind返回的是一个永久改this指向的函数。 11.2 区别共同点： 三者都可以改变函数的this对象指向。 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window。 区别： 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。 bind是返回绑定this之后的函数，apply和call是立即执行。 12. new的实现原理new 方法主要分为四个步骤： 创建一个对象 将构造函数中的this指向该对象 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 1234567891011121314151617function _new(obj, ...rest){ // 基于obj的原型创建一个新的对象 const newObj = Object.create(obj.prototype); // 添加属性到新创建的newObj上, 并获取obj函数执行的结果. const result = obj.apply(newObj, rest); // 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象 return typeof result === 'object' ? result : newObj;}// 使用function obj(name, age) { this.name = name; this.age = age;}console.log(_new(obj, &quot;zwx&quot;, 18)); 13. JavaScript脚本延迟加载的方式与区别13.1 默认&lt;script&gt;让我们首先定义&lt;script&gt;没有任何属性的情况。HTML 文件将被解析，直到脚本文件被命中，此时解析将停止，并且将发出请求来获取该文件（如果它是外部的）。然后将在恢复解析之前执行该脚本。 13.2 异步加载&lt;script async&gt;async在 HTML 解析期间下载文件，并在下载完成后暂停 HTML 解析器以执行该文件。 13.3延迟加载&lt;script defer&gt;defer在 HTML 解析期间下载文件，并且仅在解析器完成后才执行它。defer脚本还保证按照它们在文档中出现的顺序执行。 14. Ajax、Fetch、Axios三者的区别14.1 Ajax它的全称是：Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。 Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新，无需重载整个页面。 简单来说，Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。 123456789101112131415161718&lt;body&gt; &lt;script&gt; function ajax(url) { const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, false); xhr.onreadystatechange = function () { // 异步回调函数 if (xhr.readyState === 4) { if (xhr.status === 200) { console.info(&quot;响应结果&quot;, xhr.response) } } } xhr.send(null); } ajax('https://smallpig.site/api/category/getCategory') &lt;/script&gt;&lt;/body&gt; 我们使用这种方式实现网络请求时，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。 14.2 FetchFetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象。它是 XMLHttpRequest 的替代品。 特点： 使用 promise，不使用回调函数。 采用模块化设计，比如 rep、res 等对象分散开来，比较友好。 通过数据流对象处理数据，可以提高网站性能。 12345678910&lt;body&gt; &lt;script&gt; function ajaxFetch(url) { fetch(url).then(res =&gt; res.json()).then(data =&gt; { console.info(data) }) } ajaxFetch('https://smallpig.site/api/category/getCategory') &lt;/script&gt;&lt;/body&gt; 上段代码利用 Fetch 发送了一个最简单的 get 请求，其中最重要的特点之一就是采用了.then 链式调用的方式处理结果，这样不仅利于代码的可读，而且也解决了回调地狱的问题。 14.3 AxiosAxios 是一个基于 promise 封装的网络请求库，它是基于 XHR 进行二次封装。 特点： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 所以说，Axios 可以说是 XHR 的一个子集，而 XHR 又是 Ajax 的一个子集。 123456789// 发送 POST 请求axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' }}) 14.4 总结","link":"/blog/2024/04/21/JavaScript%E7%AC%94%E8%AE%B0/"},{"title":"React笔记","text":"1. render propsrender props 是一种在 React 组件间使用一个值为函数的 props 共享代码的技术，具体说就是一个用于告知组件需要显然什么内容的函数 props 1234567891011121314151617class DataProvider extends React.Components { state = { name: 'Tom' } render() { return ( &lt;div&gt; &lt;p&gt;共享数据组件自己内部的渲染逻辑，调用props中的函数渲染内容&lt;/p&gt; {this.props.render(this.state)} &lt;/div&gt; ) }}// 调用方式&lt;DataProvider render={data =&gt; (&lt;h1&gt;Hello {data.name}&lt;/h1&gt;)}&lt;/DataProvider&gt; 优点：数据共享，代码复用，将组件内的 state 作为 props 传递给调用者，将渲染逻辑交给调用者 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅 2. React fiber2.1 React 16 以前的DOM更新流程 JSX 转 VDOM 新旧 VDOM 作比较（老架构是 递归遍历 VDOM，不能中断） 递归结束，通知 Renderer（渲染器），将最新的 VDOM 渲染到页面上 2.2 缺点React 16前，采用的是 递归遍历新旧 VDOM 树做对比，这会存在一个问题：递归时，如果 VDOM树层级很深，那么会长时间占用 JS 主线程，而 JS又是单线程的，且递归又是同步递归的，就会导致页面上的某些交互操作无法响应、动画卡顿等问题。所以为了解决这个问题，React 16后，新增了 Fiber 架构。 2.3 React15和React6架构的区别React15架构可以分为两层： Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 React16架构可以分为三层： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 2.3 Fiber DOM 更新流程Fiber架构使用协程来优化React应用程序的渲染过程。协程允许在渲染过程中暂停和重新启动组件的渲染，这使得可以优先处理优先级较高的组件，从而提高性能。 Scheduler 给每个更新任务赋予优先级 优先级高的更新任务A，会被推入 Reconciler（协调器），VDOM 转 Fiber，新的 VDOM 和 旧的 Fiber 进行 diff 对比决定怎样生成新的 Fiber 。但如果此时有新的更高优先级的更新任务B 进入 Scheduler，那么 A 就会被中断，B被推入 Reconciler（协调器），当 B 完成渲染后。新一轮的调度开始，A 是新一轮中优先级最高的，那 A 就继续推入 Reconciler 执行更新任务。 重复以上的 可中断、可重复 步骤，直至所有更新任务完成渲染。 2.4 Fiber 双缓存React 更新DOM 采用的是双缓存技术。React 中最多会存在两颗 Fiber树： currentFiber：页面中显示的内容 workInProgressFiber：内存中正在重新构建的 Fiber树。 双缓存中：当 workInProgressFiber 在内存中构建完成后，React 会直接用它 替换掉 currentFiber，这样能快速更新 DOM。一旦 workInProgressFiber树 渲染在页面上后，它就会变成 currentFiber 树，也就是说 fiberRootNode 会指向它。在 currentFiber 中有一个属性 alternate 指向它对应的 workInProgressFiber，同样，workInProgressFiber 也有一个属性 alternate 指向它对应的 currentFiber。也就是下面的这种结构： 3. React context 的弊端要想使消费组件进行重渲染，context value 必须返回一个全新对象，这将导致所有消费组件都进行重渲染，这个开销是非常大的，因为有一些组件所依赖的值可能并未发生变化。 3.1 对比useSelectorreact-redux useSelector 则是采用订阅 redux store.state 更新，去通知消费组件「按需」进行重渲染（比较所依赖的 state 前后是否发生变化）。 4. 如何解决刷新页面redux数据丢失问题 可以使用sessionStorage或者localStorage 使用redux-persist插件，但其实本质还是将数据缓存到了sessionStorage或者localStorage 5. connect实现原理创建一个context，用于将store放入其中 1234import { createContext } from &quot;react&quot;;export const StoreContext = createContext(); 将store放入context 123&lt;StoreContext.Provider value={store}&gt; &lt;App /&gt;&lt;/Provider&gt; connect实现 1234567891011121314151617181920212223242526272829303132333435import { PureComponent } from &quot;react&quot;;import {StoreContext} from &quot;./StoreContext&quot;;export function connect(mapStateToProps, mapDispatchToProps) { return function(WrapperComponent) { class NewComponent extends PureComponent { // constructor的第二个参数就是context constructor(props, context) { super(props); this.state = mapStateToProps(context.getState()); } componentDidMount() { this.unsubscribe = this.context.subscribe(() =&gt; { // 使用this.context是为了将自己写的connect与store解藕 this.setState(mapStateToProps(this.context.getState())); }) } componentWillUnmount() { this.unsubscribe(); } render() { const stateObj = mapStateToProps(this.context.getState()); const dispatchObj = mapDispatchToProps(this.context.dispatch); return &lt;WrapperComponent {...this.props} {...stateObj} {...dispatchObj}/&gt;; } } // 设置组件的contextType为某一个Context NewComponent.contextType = StoreContext; return NewComponent; }} 6. 为何要在componentDidMount里面发送请求 如果要获取外部数据（发送异步请求）并加载到组件上，只能在组件已经挂载到真实的网页上才能做这件事，其他情况是加载不到组件的。 componentDidMount方法中的代码，是在组件已经挂载到网页上才会被执行，所以可以保证数据的加载。此外，在这个方法中调用setState方法，会触发重新渲染。 componentWillMount方法中调用setState不会触发重新渲染，所以一般不用来做数据加载。 7. hash和history路由的区别7.1 SPA与前端路由SPA（单页面应用，全程为：Single-page Web applications）指的是只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序，简单通俗点就是在一个项目中只有一个html页面，它在第一次加载页面时，将唯一完成的html页面和所有其余页面组件一起下载下来，所有的组件的展示与切换都在这唯一的页面中完成，这样切换页面时，不会重新加载整个页面，而是通过路由来实现不同组件之间的切换。单页面应用（SPA）的核心之一是：更新视图而不重新请求页面。优点： 具有桌面应用的即时性、网站的可移植性和可访问性 用户体验好、快，内容的改变不需要重新加载整个页面 良好的前后端分离，分工更明确 缺点： 不利于搜索引擎的抓取 首次渲染速度相对较慢 7.2 hash简述 vue-router 默认为 hash 模式，使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会重新加载；**# 就是 hash符号，中文名为哈希符或者锚点，在 hash 符号后的值称为 hash 值**。 路由的 hash 模式是利用了 window 可以监听 onhashchange 事件来实现的，也就是说 hash 值是用来指导浏览器动作的，对服务器没有影响，HTTP 请求中也不会包括 hash 值，同时每一次改变 hash 值，都会在浏览器的访问历史中增加一个记录，使用“后退”按钮，就可以回到上一个位置。所以，hash 模式 是根据 hash 值来发生改变，根据不同的值，渲染指定DOM位置的不同数据。 特点 url中带一个 # 号 可以改变URL，但不会触发页面重新加载（hash的改变会记录在 window.hisotry 中）因此并不算是一次 HTTP 请求，所以这种模式不利于 SEO 优化 只能修改 # 后面的部分，因此只能跳转与当前 URL 同文档的 URL 只能通过字符串改变 URL 通过 window.onhashchange 监听 hash 的改变，借此实现无刷新跳转的功能。 每改变一次 hash （ window.location.hash）,都会在浏览器的访问历史中增加一个记录。 路径中从 # 开始，后面的所有路径都叫做路由的 哈希值 并且哈希值它不会作为路径的一部分随着 http 请求，发给服务器 7.3 history简述 history 是路由的另一种模式，在相应的 router 配置时将 mode 设置为 history 即可。 history 模式是通过调用 window.history 对象上的一系列方法来实现页面的无刷新跳转。 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。 这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会向后端发送请求。 特点 新的URL可以是与当前URL同源的任意 URL，也可以与当前URL一样，但是这样会把重复的一次操作记录到栈中。 通过参数stateObject可以添加任意类型的数据到记录中。 可额外设置title属性供后续使用。 通过pushState、replaceState实现无刷新跳转的功能。 路径直接拼接在端口号后面，后面的路径也会随着http请求发给服务器，因此前端的URL必须和向发送请求后端URL保持一致，否则会报404错误。 由于History API的缘故，低版本浏览器有兼容行问题。 8. Redux和Vuex的区别 Redux使用的是不可变数据，而Vuex的数据是可变的。Redux每次是用新的state去替换旧的state，而Vuex是直接修改。 Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化） Redux Vuex 9. Redux中的connect有什么作用connect负责连接React和Redux： 获取state connect 通过 context 获取 Provider 中的 store ，通过 store.getState() 获取整个 store tree 上的所有 state 包装原组件 将 state 和 action 通过 props 的方式传入到原组件中 监听 store tree 的变化 connect 缓存了 store tree 中的 state 的状态，通过当前的 state 和变更前的 state 进行比较，从而确定是否调用 setState 方法触发 Connect 及其自组件的重新渲染 案例： 123456789101112131415161718192021222324252627282930313233343536import { PureComponent } from &quot;react&quot;;import {StoreContext} from &quot;./StoreContext&quot;;export function connect(mapStateToProps, mapDispatchToProps) { return function(WrapperComponent) { class NewComponent extends PureComponent { // constructor的第二个参数就是context constructor(props, context) { super(props); // 获取整个store tree上的state this.state = mapStateToProps(context.getState()); } componentDidMount() { this.unsubscribe = this.context.subscribe(() =&gt; { // 使用this.context是为了将自己写的connect与store解藕 this.setState(mapStateToProps(this.context.getState())); }) } componentWillUnmount() { this.unsubscribe(); } render() { const stateObj = mapStateToProps(this.context.getState()); const dispatchObj = mapDispatchToProps(this.context.dispatch); return &lt;WrapperComponent {...this.props} {...stateObj} {...dispatchObj}/&gt;; } } // 设置组件的contextType为某一个Context NewComponent.contextType = StoreContext; return NewComponent; }} 10. 为什么useState要使用数组而不是对象useState 返回的是数组而不是对象，原因是为了降低使用复杂度，返回数组的话可以直接根据顺序解构，而返回对象的话想要使用多次就需要定义别名了。比如： 12345// 第一次使用const { state, setState} = useState(false);// 第二次使用const { state: counter, setState: setCounter } = useState(0); 11. 为什么不能在if和循环里调用Hooks因为React的函数式组件每次渲染都会重新生成状态，且每一次渲染都有一个状态序列，如果在if里调用，就可能导致某次渲染的时候状态序列有缺失，从而出现异常。例如：对于下面这段代码，在React内部的状态序列是0 -&gt; xiaoming。 如果在if里调用，那就会出现只有 0 这样的状态序列，就会出现渲染异常： 11.1 为什么Hooks要保证状态序列呢？因为我们在使用useState声明状态时，只赋给了状态初始值，而并没有给状态加key。在类组件的时候我们是这样声明状态的： 而在函数式组件中，我们是这样声明状态的： 仔细看就会发现，类组件的状态是以一个对象形式储存的，每个状态都有一个key和value相对应。而在函数式组件中，useState方法只接受了状态的初始值作为参数，并没有key，所以，函数式组件的状态不能以对象的形式存储，只能以线性表的形式存储，比如说数组和链表。实际上，Hooks状态是用链表来存的。但是无论是数组还是链表，都需要保持顺序，这样才能使每次渲染的序列对得上。 12. React与Vue的diff算法的区别 react在diff遍历的时候，只对需要修改的节点进行了记录，形成effect list，最后才会根据effect list 进行真实dom的修改，修改时先删除，然后更新与移动，最后插入 vue 在遍历的时候就用真实dominsertBefore方法，修改了真实dom，最后做的删除操作 react 采用单指针从左向右进行遍历。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动 vue采用双指针，从两头向中间进行遍历。当一个集合只是把最后一个节点移到了第一个，vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。 vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。 13. React严格模式13.1 什么是严格模式StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 13.2 作用 检测副作用 对于在应用中使用已经废弃、过时的方法会发出警告 React 18的文档提到的更多的是purity，即纯度，这其实是函数式编程的理念，这与React 17文档中提到的无副作用是一个意思，react hooks函数式组件实际上就是函数式编程理念的体现。编写纯函数带来了一定的心智负担，但随着开发者对其接受度的提高，新文档中大量使用了purity进行相关描述。文档中提到，纯函数带来了以下优势： 多环境运行。例如可以运行在服务端，因为同样的输入，总是对应同样的输出，因此组件可以被其他人复用； 减少重复渲染。如果函数组件的输入没有改变，直接复用就好啦，不需要重复渲染。 随时中断渲染。在渲染层级较深的组件树时，数据发生了改变，那么React可以马上重新开始渲染，而不用等待过时的渲染完成。 因此StrictMode就是在开发中帮助我们进行检测，保证我们编写的函数组件都是 ‘纯’ 的，这也就解释了为什么开头提到的为什么组件会执行两次，StrictMode会多执行一次，两次执行的结果相同，证明我们编写的的确是纯函数。 14. 服务器端渲染（SSR）14.1 简介 在用户访问时，React SSR（下图中的 SSR with hydration 一类）将 React 组件提前在服务器渲染成 HTML 发送给客户端，这样客户端能够在 JavaScript 渲染完成前展示基本的静态 HTML 内容，减少白屏等待的时间。 然后在 JavaScript 加载完成后对已有的 HTML 组件进行 React 事件逻辑绑定（也就是 Hydration 过程），Hydration 完成后才是一个正常的 React 应用。 14.2 弊端 服务端需要准备好所有组件的 HTML 才能返回。如果某个组件需要的数据耗时较久，就会阻塞整个 HTML 的生成。 Hydration 是一次性的，用户需要等待客户端加载所有组件的 JavaScript 并 Hydrated 完成后才能和任一组件交互。（渲染逻辑复杂时，页面首次渲染到可交互之间可能存在较长的不可交互时间） 在 React SSR 中不支持客户端渲染常用的代码分割组合React.lazy和Suspense。 而在 React 18 中新的 SSR 架构React Fizz带来了两个主要新特性来解决上述的缺陷：Streaming HTML（流式渲染）和Selective Hydration（选择性注水） 14.3 流式渲染（Streaming HTML）一般来说，流式渲染就是把 HTML 分块通过网络传输，然后客户端收到分块后逐步渲染，提升页面打开时的用户体验。通常是利用HTTP/1.1中的分块传输编码（Chunked transfer encoding）机制。 15. Babel原理15.1 什么是BabelBabel 是一个 JavaScript 编译器。他把最新版的javascript编译成当下可以执行的版本，简言之，利用babel就可以让我们在当前的项目中随意的使用这些新最新的es6，甚至es7的语法。起初，JavaScript 与服务器语言不同，它没有办法保证对每个用户都有相同的支持，因为用户可能使用支持程度不同的浏览器（尤其是旧版本的 Internet Explorer）。如果开发人员想要使用新语法（例如 class A {}），旧浏览器上的用户只会因为 SyntaxError 的错误而出现屏幕空白的情况。Babel 为开发人员提供了一种使用最新 JavaScript 语法的方式，同时使得他们不必担心如何进行向后兼容，如（class A {} 转译成 var A = function A() {}）。 15.2 Babel运行原理Bebel的转译过程分为三个阶段： 解析：将代码解析生成抽象语法树，即词法分析与语法分析两个过程。 转换：对抽象语法树进行一系列变换。 生成：将转换后的抽象语法树再转换成js代码。 15.2.1 解析词法分析词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。你可以把令牌看作是一个扁平的语法片段数组： 12345678910111213141516171819202122[ { &quot;type&quot;: &quot;Keyword&quot;, &quot;value&quot;: &quot;let&quot; }, { &quot;type&quot;: &quot;Identifier&quot;, &quot;value&quot;: &quot;name&quot; }, { &quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;=&quot; }, { &quot;type&quot;: &quot;String&quot;, &quot;value&quot;: &quot;ljc&quot; }, { &quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;;&quot; }] 每一个 type 有一组属性来描述该令牌： 12345678910111213141516{ type: { label: 'name', keyword: undefined, beforeExpr: false, startsExpr: true, rightAssociative: false, isLoop: false, isAssign: false, prefix: false, postfix: false, binop: null, updateContext: null }, ...} 和 AST 节点一样它们也有 start，end，loc 属性。 语法分析语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。简单来说，解析阶段就是 1code(字符串形式代码) -&gt; tokens(令牌流) -&gt; AST（抽象语法树） 将上一步的 token 数据进行递归的组装，生成 AST，按照不同的语法结构，来把一组单词组合成对象，这个过程就是语法分析，比如上面的代码，就会生成这样的 AST 123456789101112131415161718192021222324{ &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ { &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;declarations&quot;: [ { &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;id&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;name&quot; }, &quot;init&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;ljc&quot;, &quot;raw&quot;: &quot;\\&quot;ljc\\&quot;&quot; } } ], &quot;kind&quot;: &quot;let&quot; } ], &quot;sourceType&quot;: &quot;module&quot;} Babel 使用 @babel/parser 解析代码，输入的 js 代码字符串根据 ESTree 规范生成 AST（抽象语法树）。Babel 使用的解析器是 babylon。 15.2.2 转换转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程。Babel提供了@babel/traverse(遍历)方法维护这AST树的整体状态，并且可完成对其的替换，删除或者增加节点，这个方法的参数为原始AST和自定义的转换规则，返回结果为转换后的AST。 15.2.3 生成代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。Babel使用 @babel/generator 将修改后的 AST 转换成代码，生成过程可以对是否压缩以及是否删除注释等进行配置，并且支持 sourceMap。 16. JSX 是如何通过 Babel 转换成 JS 代码的JSX 是 React.createElement 的语法糖，在 All in JS 的世界里，想要保留住 HTML 这种标签语法的结构和层次感，于是有了 JSX，让我们可以在 JS 中编写 HTML，但实际上最终交由浏览器处理的还是 JS。JSX 会通过 Babel 最终转化成 React.createElement` 的这种形式。 1234567891011function test() { return &lt;div class=&quot;hello&quot;&gt;world&lt;/div&gt;}// 转换成&quot;use strict&quot;;function test() { return /*#__PURE__*/React.createElement(&quot;div&quot;, { class: &quot;hello&quot; }, &quot;world&quot;);} 第一个参数是要创建的元素的 Tag 值。 第二个参数是我们传给元素的 props 值，在生成的 JS 代码中，是以一个普通对象，以键值对的方式存在。 第三个参数是 children。 17. React中常用的Hooks有哪些17.1 uesState：让函数具有维持状态的能力uesState用来管理状态，在一个组件的多次渲染中，state是共享的。 17.2 useEffect：执行副作用默认情况下，useEffect会在第一次渲染和更新之后都会执行，相当于在componentDidMount和componentDidUpdate两个生命周期函数中执行回调。 回调函数中可以返回一个清除函数，这是effect可选的清除机制，相当于类组件中componentwillUnmount生命周期函数，可做一些清除副作用的操作。 useEffect接收两个参数： 第一个为要执行的函数callback 第二个是个可选参数，是一个依赖项数组 依赖项是可选的： 如果不指定，那么callback每次都会执行 如果指定了，那么只有依赖项中的值发生了变化的时候，才会执行callback 17.3 uesMemo与uesCallbackuesMemo的使用：缓存计算结果 useCallback的使用：缓存回调函数 相同点： 两者接收的参数都是一样的，第一个参数表示一个回调函数，第二个表示依赖的数据。 两者都是仅仅当依赖的数据发生变化时, 才会重新计算结果，也就是起到缓存的作用。 都是用来作为性能优化。 不同点： useMemo 计算结果是 return 回来的值, 主要用于缓存计算结果的值 ，应用场景如： 需要计算的状态 useCallback 计算结果是函数, 主要用于缓存函数，应用场景如: 需要缓存的函数。因为函数式组件每次任何一个 state 的变化, 整个组件都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，减少资源浪费。 useCallback 的功能其实是可以用 useMemo 来实现的。当我们在useMemo中return的是一个函数的时候，实际上与useCallback的功能是相同的。所以说useMemo与useCallback有异曲同工之处。 17.4 uesRef：在多次渲染之间共享数据可以把 useRef 看作是在函数组件之外创建的一个容器空间。在这个容器上，可以通过唯一的 current 属性设置一个值，从而在函数组件的多次渲染之间共享这个值。 使用 useRef 保存的数据一般是和 UI 的渲染无关的，因此当 ref 的值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。 可以通过useRef保存某个 DOM 节点的引用。 结合 React 的 ref 属性和 useRef 这个 Hook，就可以获得真实的 DOM 节点，并对这个节点进行操作。 功能具体例子：你需要在点击某个按钮时让某个输入框获得焦点 17.5 useContext：定义全局状态React 组件之间的状态传递只有一种方式，那就是通过props。这就意味着这种传递关系只能在父子组件之间进行。 而如果需要跨层级的话，React 提供了 Context 这样一个机制。 Context这个机制，能够让所有在某个组件开始的组件树上创建一个 Context。这样这个组件树上的所有组件，就都能访问和修改这个 Context 了。 一个 Context 是从某个组件为根组件的组件树上可用的，所以需要有 API 能够创建一个 Context，就是React.createContext。 React.createContext 创建出来的值具有一个 Provider 的属性，一般是作为组件树的根组件。 这个根组件中可以通过value属性对数据进行传递。 这样的话，在后代的组件中通过useContext就可以接收到上方通过value传来的值，从而进行一系列的操作。 18. React Diff原理diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处。 react中diff算法主要遵循三个层级的策略： tree层级 component 层级 element 层级 18.1 tree层级只会对相同层级的节点进行比较。 只有删除、创建操作，没有移动操作，如下图： react发现新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。 上述操作中，只有删除和创建操作。 18.2 component层级如果是同一个类的组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的。 当component D换成了component G 后，即使两者的结构非常类似，也会将D删除再重新创建G。 18.3 element层级对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识 提供了 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)。 通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置。 19. 虚拟DOM中key的作用 简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用 详细的说：当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】，随后react进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下： 旧虚拟DOM中找到了与新虚拟DOM相同的key: 若虚拟DOM中内容没变，直接使用之前的真实DOM 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM 旧虚拟DOM中未找到与新的虚拟DOM相同的key 根据数据创建新的真实DOM，随后渲染到页面 20. 用index作为key可能会引发的问题 若对数据进行：逆序添加、逆序删除等破坏顺序的操作： 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题，但效率低 如果结构中还包含输入类的DOM 会产生错误DOM更新 ==&gt; 界面有问题 注意，如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type=&quot;text/babel&quot;&gt; //创建组件 class Person extends React.Component { state = { persons: [ { id: 1, name: '小张', age: 18 }, { id: 2, name: '小杨', age: 18 } ] } add = () =&gt; { const {persons} = this.state; const p = {id: persons.length+1, name: '小李', age: 18}; this.setState({persons: [p, ...persons]}); } render() { return ( &lt;div&gt; &lt;h2&gt;展示人员信息&lt;/h2&gt; &lt;button onClick={this.add}&gt;添加一个小李&lt;/button&gt; &lt;h3&gt;使用index作为key&lt;/h3&gt; &lt;ul&gt; { this.state.persons.map((person, index) =&gt; { return &lt;li key={index}&gt;{person.name}---{person.age}&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt; }) } &lt;/ul&gt; &lt;hr/&gt; &lt;h3&gt;使用id作为key&lt;/h3&gt; &lt;ul&gt; { this.state.persons.map((person) =&gt; { return &lt;li key={person.id}&gt;{person.name}---{person.age}&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt; }) } &lt;/ul&gt; &lt;/div&gt; ) } } //渲染组件 ReactDOM.render(&lt;Person /&gt;, document.getElementById('test')); &lt;/script&gt; 这时，逆序添加后，key对应的标签里的数据全部都变了，所以会引起所有li标签的重新渲染。","link":"/blog/2024/04/21/React%E7%AC%94%E8%AE%B0/"},{"title":"Redux状态管理","text":"1. 为什么需要Redux JavaScript开发的应用程序，已经变得越来越复杂了： Javascript需要管理的状态(state)越来越多，越来越复杂; 这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等，也包括一些UI的状态，比如某些元素是否被选中，是否显示加载动效，当前分页; 管理不断变化的state是非常困难的： 状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View页面也有可能会引起状态的变化； 当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪; React是在视图层帮助我们解决了DOM的渲染过程，但是State依然是留给我们自己来管理： 无论是组件定义自己的state，还是组件之间的通信通过props进行传递；也包括通过Context进行数据之间的共享； React主要负责帮助我们管理视图，state如何维护最终还是我们自己来决定； Redux就是一个帮助我们管理State的容器：Redux是JavaScript的状态容器，提供了可预测的状态管理 Redux除了和React一起使用之外，它也可以和其他界面库一起来使用（比如Vue），并且它非常小（包括依赖在内，只有2kb) 2. Redux核心理念-Store Redux的核心理念非常简单，比如我们有一个朋友列表需要管理： 如果我们没有定义统一的规范来操作这段数据，那么整个数据的变化就是无法跟踪的; 比如页面的某处通过products.push的方式增加了一条数据； 比如另一个页面通过products[0].age = 25修改了一条数据; 整个应用程序错综复杂，当出现bug时，很难跟踪到底哪里发生的变化; 1234567const initialState = { friends: [ { name: &quot;why&quot;, age: 18 }, { name: &quot;kobe&quot;, age: 40 }, { name: &quot;lilei&quot;, age: 30 } ]}; 3. Redux核心理念-Action Redux要求我们通过action来更新数据： 所有数据的变化，必须通过派发 (dispatch) action来更新； action是一个普通的JavaScript对象，用来描述这次更新的type和content; 比如下面就是几个更新friends的action： 强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的； 当然，目前我们的action是固定的对象； 真实应用中，我们会通过函数来定义，返回一个action; 123const action1 = { type: &quot;ADD_FRIEND&quot;, info: { name: &quot;lucy&quot;, age: 20 } }const action2 = [ type: &quot;INC_AGE&quot;, index: 0 }const action3 = { type: &quot;CHANGE NAME&quot;, playload: { index: 0, newName: &quot;coderwhy&quot; } } 4. Redux核心理念-Reducer 如何将state和action联系在一起？使用reducer reducer是一个纯函数 reducer做的事情就是将传入的state和action结合起来生成一个新的state 5. Redux的基本使用创建redux 1234567891011121314151617181920212223242526const {createStore} = require(&quot;redux&quot;);// 初始化的数据const initialState = { name: 'zwx', age: 18}// 定义reducer函数：纯函数// 参数一：store中目前保存的state// 参数二：本次需要更新的action（dispatch传入的action）// 返回值：作为store之后存储的statefunction reducer(state = initialState, action) { // 有新数据进行更新的时候，那么就返回一个新的state if (action.type === &quot;change_name&quot;) { return {...state, name: action.name}; } // 没有新数据就返回之前的state return state;}// 创建storeconst store = createStore(reducer)module.exports = store; 修改store中的数据 12345678const store = require(&quot;./store&quot;);console.log(store.getState);// 修改store中的数据：必须通过actionconst nameAction = {type: &quot;change_name&quot;, name: &quot;ysx&quot;};store.dispatch(nameAction);console.log(store.getState()); 6. store数据订阅使用store.subscribe()进行数据订阅 12345678910111213141516const store = require(&quot;./store&quot;);// 订阅数据变化const unsubscribe = store.subscribe(() =&gt; { console.log(&quot;订阅数据的变化:&quot;, store.getState());})// 修改store中的数据：必须通过actionstore.dispatch({type: &quot;change_name&quot;, name: &quot;ysx&quot;});store.dispatch({type: &quot;change_name&quot;, name: &quot;yxx&quot;});// 取消订阅unsubscribe();// 修改counterstore.dispatch({type: &quot;add_number&quot;, num: 10}); 7. Redux的三大原则7.1 单一数据源 整个应用程序的state被存储在一棵object tree中，并且这个object tree只存储在一个 store 中 Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护 单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改 7.2 State是只读的 唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State 这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state 这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题 7.3 使用纯函数来执行修改 通过reducer将旧 state 和 actions 联系在一起，并且返回一个新的state 随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分 但是所有的reducer都应该是纯函数，不能产生任何的副作用 8. 在React中使用Redux8.1 创建store123456import { createStore } from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;const store = createStore(reducer);export default store; 8.2 创建常量类型12export const ADD_NUMBER = &quot;add_number&quot;;export const SUB_NUMBER = &quot;sub_number&quot;; 8.3 创建action1234567891011import * as actionTypes from &quot;./constants&quot;export const addNumberAction = (num) =&gt; ({ type: actionTypes.ADD_NUMBER, num})export const subNumberAction = (num) =&gt; ({ type: actionTypes.SUB_NUMBER, num}) 8.4 创建reducer123456789101112131415161718import * as actionTypes from './constants'const initialState = { counter: 0}function reducer(state = initialState, action) { switch (action.type) { case actionTypes.ADD_NUMBER: return {...state, counter: state.counter + action.num}; case actionTypes.SUB_NUMBER: return {...state, counter: state.counter - action.num} default: return state; }}export default reducer; 8.5 在组件中使用redux123456789101112131415161718192021222324252627282930313233343536373839import React, { PureComponent } from 'react'import store from '../store'import {addNumberAction} from '../store/actionCreators'export class Home extends PureComponent { constructor() { super(); this.state = { counter: store.getState().counter } } componentDidMount() { store.subscribe(() =&gt; { const state = store.getState(); this.setState({counter: state.counter}); }) } addNumber(num) { store.dispatch(addNumberAction(num)); } render() { const {counter} = this.state; return ( &lt;div&gt; &lt;h2&gt;Home Counter: {counter}&lt;/h2&gt; &lt;div&gt; &lt;button onClick={e =&gt; this.addNumber(1)}&gt;+1&lt;/button&gt; &lt;button onClick={e =&gt; this.addNumber(5)}&gt;+5&lt;/button&gt; &lt;button onClick={e =&gt; this.addNumber(8)}&gt;+8&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) }}export default Home 9. react-redux库的使用 可以看到在上面的示例中，每个组件都有很多重复的代码 比如构造函数中需要写store要用到的数据，并且需要在componentDidMount订阅redux 我们可以将重复的代码封装到一个高阶组件中 这时候就需要用到react-redux库 9.1 安装react-redux1npm install react-redux 9.2 给整个应用程序提供store12345import store from './store';&lt;Provider store={store}&gt; &lt;App /&gt;&lt;/Provider&gt; 9.3 在组件中使用reduxmapStateToProps函数的返回值是一个对象，对象中包含的属性就是本组件需要用到的数据当state中的这些值发生改变时，render就会重新渲染当前组件connect是一个高阶组件，同时其返回值也是一个高阶组件 1234567891011121314151617181920212223242526272829303132333435363738import React, { PureComponent } from 'react'import { connect } from 'react-redux';import {addNumberAction, subNumberAction} from '../store/actionCreators'export class About extends PureComponent { changeNumber(num, isAdd) { if (isAdd) { this.props.addNumber(num); } else { this.props.subNumber(num); } } render() { const {counter} = this.props; return ( &lt;div&gt; &lt;h2&gt;About Page: {counter}&lt;/h2&gt; &lt;button onClick={e =&gt; this.changeNumber(6, true)}&gt;+6&lt;/button&gt; &lt;button onClick={e =&gt; this.changeNumber(6, false)}&gt;-6&lt;/button&gt; &lt;/div&gt; ) }}const mapStateToProps = (state) =&gt; ({ counter: state.counter})const mapDispatchToProps = (dispatch) =&gt; ({ addNumber(num) { dispatch(addNumberAction(num)); }, subNumber(num) { dispatch(subNumberAction(num)); }})// connect返回值是一个高阶组件export default connect(mapStateToProps, mapDispatchToProps)(About) 10. redux-thunk库的使用10.1 redux-thunk是如何支持发送异步请求的 我们知道，默认情况下的dispatch(action)，action需要是一个JavaScript的对象 redux-thunk可以让dispatch(action函数)，action可以是一个函数 该函数会被调用，并且会传给这个函数一个dispatch函数和getstate函数 dispatch函数用于我们之后再次派发action getstate函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态 10.2 案例redux-thunk用于增强redux，原本redux中的dispatch只能返回一个对象通过使用thunk，可以返回一个函数，这主要是在异步请求获取数据的时候会用到案例： 1234567import { createStore, applyMiddleware } from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;import thunk from &quot;redux-thunk&quot;;const store = createStore(reducer, applyMiddleware(thunk));export default store; 12345678910111213141516171819202122232425import * as actionTypes from &quot;./constants&quot;import axios from 'axios'export const changeBannersAction = (banners) =&gt; ({ type: actionTypes.CHANGE_BANNERS, banners})export const changeRecomendsAction = (recommends) =&gt; ({ type: actionTypes.CHANGE_RECOMMENDS, recommends})export const fetchHomeMultidataAction = () =&gt; { return function(dispatch, getState) { axios.get(&quot;http://123.207.32.32:8080/home/multidata&quot;).then(res =&gt; { const banners = res.data.banner.list; const recommends = res.data.data.recommend.list; dispatch(changeBannersAction(banners)); dispatch(changeRecomendsAction(recommends)); }) }} 12345678910111213141516171819202122232425import React, { PureComponent } from 'react'import {fetchHomeMultidataAction} from '../store/actionCreators'import { connect } from 'react-redux';export class Category extends PureComponent { componentDidMount() { this.props.fetchHomeMultidata(); } render() { return ( &lt;div&gt; &lt;h2&gt;Category&lt;/h2&gt; &lt;/div&gt; ) }}const mapDispatchToProps = (dispatch) =&gt; ({ fetchHomeMultidata() { dispatch(fetchHomeMultidataAction()) }})export default connect(null, mapDispatchToProps)(Category) 11. combineReducers函数11.1. 简介 目前我们合并的方式是通过每次调用reducer函数自己来返回一个新的对象 事实上，redux给我们提供了一个combineReducers函数可以方便的让我们对多个reducer进行合并 1234const reducer = combineReducers({ counter: counterReducer, home: homeReducer}) combineReducers是如何实现的 事实上，它也是将我们传入的reducers合并到一个对象中，最终返回一个combination的函数（相当于我们之前的reducer函数了） 在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state; 新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新； 11.2 combineReducers实现原理123456function reducer(state = {}, action) { return { counter: counterReducer(state.counter, action), home: homeReducer(state.home, action) }} 12. Redux Toolkit12.1 简介 在前面我们学习Redux的时候应该已经发现，redux的编写逻辑过于的繁琐和麻烦 并且代码通常分拆在多个文件中（虽然也可以放到一个文件管理，但是代码量过多，不利于管理） Redux Toolkit包旨在成为编写Redux逻辑的标准方式，从而解决上面提到的问题 在很多地方为了称呼方便，也将之称为“RTK” 12.2 安装1npm install @reduxjs/toolkit react-redux 12.3 核心API configureStore：包装createStore 以提供简化的配置选项和良好的默认值。它可以自动组合你的 slice reducer，添加你提供的任何 Redux 中间件，redux-thunk默认包含，并启用 Redux DevTools Extension createSlice：接受reducer函数的对象、切片名称和初始状态值，并自动生成切片reducer，并带有相应的actions createAsyncThunk：接受一个动作类型字符串和一个返回promise的函数，并生成一个pending/fulfilled/rejected基于该promise分派动作类型的thunk 12.4 createSlice参数： name：用户标记slice的名词 在之后的redux-devtool中会显示对应的名词 initialState：初始化值 第一次初始化时的值 reducer：相当于之前的reducer函数 对象类型，并且可以添加很多函数 函数类似于redux原来reducer中的一个case语句 函数的参数： 参数一：state 参数二：调用这个action时，传递的action参数 createSlice返回值是一个对象，包含所有的actions案例： 12345678910111213141516171819import { createSlice } from &quot;@reduxjs/toolkit&quot;;const counterSlice = createSlice({ name: &quot;counter&quot;, initialState: { counter: 0 }, reducers: { addNumber(state, action) { }, subNumber(state, action) { } }})export const {addNumber, subNumber} = counterSlice.actions;export default counterSlice.reducer; 相当于： 12.5 configureStoreconfigureStore用于创建store对象，常见参数如下 reducer：将slice中的reducer可以组成一个对象传入此处 middleware：可以使用参数，传入其他的中间件 devTools：是否配置devTools工具，默认为true 案例： 123456789101112import { configureStore } from &quot;@reduxjs/toolkit&quot;;import counterReducer from &quot;./features/counter&quot;;import homeReducer from &quot;./features/home&quot;;const store = configureStore({ reducer: { counter: counterReducer, home: homeReducer }})export default store; 12.6 案例编写counterSlice，相当于之前的constants + actionCreators + reducer 12345678910111213141516171819202122import { createSlice } from &quot;@reduxjs/toolkit&quot;;const counterSlice = createSlice({ name: &quot;counter&quot;, initialState: { counter: 5 }, reducers: { // reducer根据action修改state，action包含type和payload两个属性 addNumber(state, action) { const {payload} = action; state.counter = state.counter + payload; }, subNumber(state, {payload}) { state.counter = state.counter - payload; } }})export const {addNumber, subNumber} = counterSlice.actionsexport default counterSlice.reducer; 创建store 12345678910import { configureStore } from &quot;@reduxjs/toolkit&quot;;import counterReducer from &quot;./features/counter&quot;const store = configureStore({ reducer: { counter: counterReducer }})export default store; 使用redux 123456789101112131415import React from 'react';import ReactDOM from 'react-dom/client';import App from './App';import {Provider} from &quot;react-redux&quot;import store from &quot;./store&quot;const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;React.StrictMode&gt; &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;); 123456789101112131415161718192021222324252627282930313233343536373839import React, { PureComponent } from 'react'import { connect } from 'react-redux'import { subNumber, addNumber } from '../store/features/counter';export class Profile extends PureComponent { subNumber(num) { // 这里的subNumber就是下面mapDispatchToProps中的subNumber this.props.subNumber(num); } addNumber(num) { this.props.addNumber(num); } render() { const {counter} = this.props; return ( &lt;div&gt; &lt;h2&gt;Page Counter: {counter}&lt;/h2&gt; &lt;button onClick={e =&gt; this.subNumber(5)}&gt;-5&lt;/button&gt; &lt;button onClick={e =&gt; this.addNumber(5)}&gt;+5&lt;/button&gt; &lt;/div&gt; ) }}const mapStateToProps = (state) =&gt; ({ counter: state.counter.counter})const mapDispatchToProps = (dispatch) =&gt; ({ addNumber(num) { // dispatch的addNumber是'../store/features/counter'中的addNumber dispatch(addNumber(num)) }, subNumber(num) { dispatch(subNumber(num)) }})export default connect(mapStateToProps, mapDispatchToProps)(Profile) 12.7 Redux Toolkit的异步操作在之前的开发中，通过redux-thunk中间件让dispatch中可以进行异步操作redux toolkit默认已经集成了thunk相关的功能：createAsyncThunk 1234export const fetchHomeMultidataAction = createAsyncThunk(&quot;fetch/homemultidata&quot;, async () =&gt; { const res = await axios.get(&quot;http://123.207.32.32:8080/home/multidata&quot;); return res.data.data;}) 当createAsyncThunk创建出来的action被dispatch时，会存在三种状态 pending：action被发出，但是还没有最终的结果 fulfilled：获取到最终的结果（有返回值的结果） rejected：执行过程中有错误或者抛出了异常 12345678910111213141516171819202122const homeSilce = createSlice({ name: &quot;home&quot;, initialState: { banners: [], recommends: [] }, // 监听异步操作 extraReducers: { // 将计算属性名作为函数名 [fetchHomeMultidataAction.pending](state, action) { console.log('fetchHomeMultidataAction pending'); }, [fetchHomeMultidataAction.fulfilled](state, {payload}) { console.log('fetchHomeMultidataAction fulfilled'); state.banners = payload.data.banner.list; state.recommends = payload.data.recommend.list; }, [fetchHomeMultidataAction.rejected](state, action) { console.log('fetchHomeMultidataAction rejected'); } }}) 12345678extraReducers: (builder) =&gt; { builder.addCase(fetchHomeMultidataAction.pending, (state, action) =&gt; { console.log(&quot;fetchHomeMultidataAction pending&quot;); }).addCase(fetchHomeMultidataAction.fulfilled, (state, {payload}) =&gt; { state.banners = payload.data.banner.list; state.recommends = payload.data.recommend.list; })} 12.8 Redux Toolkit的数据不可变性（了解） 在React开发中，我们总是会强调数据的不可变性： 无论是类组件中的state， 还是redux中管理的state 事实上在整个JavaScript编码过程中，数据的不可变性都是非常重要的 所以在前面我们经常会进行浅拷贝来完成某些操作，但是浅拷贝事实上也是存在问题的： 比如过大的对象，进行浅拷贝也会造成性能的浪费 比如浅拷贝后的对象，在深层改变时，依然会对之前的对象产生影响 事实上Redux Toolkit底层使用了immerjs的一个库来保证数据的不可变性 为了节约内存，又出现了一个新的算法：Persistent Data structure(持久化数据结构或一致性数据结构） 用一种数据结构来保存数据 当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费 13. Redux-connect函数实现原理1234567891011121314151617181920212223242526272829303132import { PureComponent } from &quot;react&quot;;import {StoreContext} from &quot;./StoreContext&quot;;export function connect(mapStateToProps, mapDispatchToProps) { return function(WrapperComponent) { class NewComponent extends PureComponent { constructor(props, context) { super(props); this.state = mapStateToProps(context.getState()); } componentDidMount() { this.unsubscribe = this.context.subscribe(() =&gt; { this.setState(mapStateToProps(this.context.getState())); }) } componentWillUnmount() { this.unsubscribe(); } render() { const stateObj = mapStateToProps(this.context.getState()); const dispatchObj = mapDispatchToProps(this.context.dispatch); return &lt;WrapperComponent {...this.props} {...stateObj} {...dispatchObj}/&gt;; } } NewComponent.contextType = StoreContext; return NewComponent; }} 123import { createContext } from &quot;react&quot;;export const StoreContext = createContext(); 12export {StoreContext} from &quot;./StoreContext&quot;;export {connect} from &quot;./connect&quot;; 使用的时候需要在App外面再包裹一层StoreContext.Provider 12345678910const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;React.StrictMode&gt; &lt;Provider store={store}&gt; &lt;StoreContext.Provider value={store}&gt; &lt;App/&gt; &lt;/StoreContext.Provider&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;);","link":"/blog/2024/08/23/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"title":"Vue笔记","text":"1. Vue的MVVM模型 M（模型Model）：对应data中的数据 V（视图View）：模版 VM（视图模型ViewModel）：Vue实例对象 Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。 1.1 MVCMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 1.2 MVPMVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。 2. 双向数据绑定原理vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发响应的监听回调来渲染视图。 原理： 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数。 此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 具体步骤： 1、需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:(1)在自身实例化时往属性订阅器(dep)里面添加自己(2)自身必须有一个update()方法(3)待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。 4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 注意： 响应式和双向数据绑定不一样。 响应式是Vue的核心特性之一，数据驱动视图，我们修改数据，视图会随之响应更新。 双向数据绑定通常是指我们使用的v-model指令的实现，是Vue的一个特性，也可以说是一个input事件和value的语法糖。 Vue通过v-model指令为组件添加上input事件处理和value属性的赋值。 3. 使用Object.defineProperty进行数据劫持有什么缺点在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或给对象新增属性，这些都不能触发组件的重新渲染，因为Object.defineProperty不能拦截到这些操作。 12345678910111213141516let arr = [1, 2, 3]const target = {};Object.defineProperty(target, 'arr', { get() { console.log('触发get'); return arr; }, set(newVal) { console.log('触发set', newVal); arr = newVal; }})console.log(target.arr);target.arr = [1, 2, 3, 4];target.arr.push(5); 对于数组而言，大部分操作都是拦截不到的，只是Vue内部通过重写函数的方式解决了这个问题。在Vue3中已经不使用这种方式了，而是通过Proxy对对象进行代理，从而实现数据劫持。使用Proxy的好处是它可以监听到任何方式的数据改变，唯一的缺点是兼容性问题，Proxy是ES6语法。 4. computed和watch的区别4.1 comutedcomputed属性是基于其依赖的响应式数据进行计算得出的属性，它会根据依赖的数据变化自动更新。computed属性是缓存的，只有在依赖的数据发生变化时才会重新计算，否则会直接返回缓存的结果。这使得computed适合用于对简单的数据进行计算或格式化操作。适合用于基于响应式数据进行计算得出属性的场景，并具有缓存机制。 4.2 watch相比之下，watch属性用于观察某个数据的变化并执行相应的操作。watch属性允许你对特定数据的变化做出响应，可以执行异步操作或复杂的逻辑。更多的是观察作用，无缓存性。适合用于监听数据的变化并执行特定操作的场景，适合执行异步操作或复杂逻辑。 5. Vue mixins混入和extends继承5.1 mixins5.1.1 作用mixins的作用时减少data、methods、钩子的重复作用 5.1.2 例子假设我们需要在每个组件上添加name和time。在created时打出提示，并在beforeDestoryed报出存活时间。新建log.js。 把重复的部分提出来。 12345678910111213141516171819202122const log = { data() { return { name: undefined, time: undefined }; }, created() { if (!this.name) { throw new Error(&quot;need name&quot;); } this.time = new Date(); console.log(`${this.name}出生了`); }, beforeDestroy() { const now = new Date(); console.log(`${this.name}死亡了，共生存了 ${now - this.time} ms`); }};export default log; 在需要应用的组件里使用 12345678910111213141516&lt;template&gt; &lt;div&gt;Child2&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引入mixinsimport log from &quot;../mixins/log.js&quot;;export default { data() { return { name: &quot;Child2&quot; }; }, mixins: [log]};&lt;/script&gt; 虽然此处，两个组件用可以通过this.name引用mixins中定义的name，但是两个组件引用的并不是同一个，而是各自创建了一个新的。如果在组件中定义相同的data，则此处会引用组件中的name，而非mixins中的。 5.1.3 选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。 同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。 1234567891011121314// 为自定义的选项 'myOption' 注入一个处理器。Vue.mixin({ created: function () { var myOption = this.$options.myOption if (myOption) { console.log(myOption) } }})new Vue({ myOption: 'hello!'})// =&gt; &quot;hello!&quot; 5.2 extends vue的extends和mixins类似，通过暴露一个extends对象到组件中使用。 extends会比mixins先执行。执行顺序：extends &gt; mixins &gt; 组件 extends只能暴露一个extends对象，暴露多个extends不会执行。 5.3 总结 extends传入的是对象写法,而mixins是数组写法 mixins可以混入多个mixin，extends只能继承一个 优先级Vue.extend &gt; extends &gt; mixins 都是对父组件的扩充，包括methods、components、钩子等 触发钩子函数时，先调用extends，mixins的函数，再调用父组件的函数 虽然也能在创建mixin时添加data、template属性，但当父组件也拥有此属性时以父为准 data、methods内函数、components和directives等键值对格式的对象均以父组件/实例为准 6. v-if和v-for为什么不能一起用6.1 原因 原因：v-for 的执行优先级要比 v-if 要高在v-for循环中，每循环一次，都需要进行v-if判断。如果循环1000次也要判断1000次，而v-if的判断相对的比较耗费性能。大量的判断会极大的降低项目质量。 6.2 如何避免方法一可以将v-if写在v-for的外层，这样就可以让v-if优先判断 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;!-- v-if写在v-for的外层 这样就可以让v-if的优先级大于v-for，就不用去判断很多次 --&gt; &lt;div v-if=&quot;x === 1&quot;&gt; 、 &lt;div v-for=&quot;(item) in list&quot; :key=&quot;item&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;IndexCom&quot;, data(){ return { list:[1,2,3,4,5,6,7,8,9,10] } }};&lt;/script&gt; 方法二当v-if的判断条件依赖于v-for的某个值时(item,index)，则可以使用如下方法这种方法不在dom上去判断是否显示，直接在计算属性（computed）上做好过滤，dom上（template中）直接遍历已经被过滤之后的计算属性。从计算成本上来说，在计算属性中过滤会比在dom中判断是否显示更低。 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;!-- 2. 然后这里去循环已经被过滤的属性 --&gt; &lt;div v-for=&quot;(item) in ListArr&quot; :key=&quot;item&quot; &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;IndexCom&quot;, data(){ return { list:[1,2,3,4,5,6,7,8,9,10] } }, computed:{ //1. 在computed里先做好判断，这里过滤的成本远比v-if的成本低 ListArr(){ return this.list.filter((_,index) =&gt; index === 1) } }};&lt;/script&gt; 6.3 总结 v-if不能和v-for一起使用的原因是v-for的优先级比v-if高，一起使用会造成性能浪费 解决方案有两种，把v-if放在v-for的外层或者把需要v-for的属性先从计算属性中过滤一次 v-if和v-for的优先级问题在vue3中不需要考虑，vue3更新了v-if和v-for的优先级，使v-if的优先级高于v-for 7. Vue和React的区别7.1 核心思想不同 Vue的核心思想是尽可能的降低前端开发的门槛，是一个灵活易用的渐进式双向绑定的MVVM框架。 React的核心思想是声明式渲染和组件化、单向数据流，React既不属于MVC也不属于MVVM架构。 7.2 组件写法上不同 Vue的组件写法是通过template的单文件组件格式。 React的组件写法是JSX+inline style，也就是把HTML和CSS全部写进JavaScript中。 7.3 Diff算法不同 vue对比节点，如果节点元素类型相同，但是className不同，认为是不同类型的元素，会进行删除重建，但是react则会认为是同类型的节点，只会修改节点属性。 vue的列表比对采用的是首尾指针法，而react采用的是从左到右依次比对的方式，当一个集合只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到最后一个，从这点上来说vue的对比方式更加高效。 7.4 响应式原理不同 React主要是通过setState()方法来更新状态，状态更新之后，组件也会重新渲染。 vue会遍历data数据对象，使用Object.definedProperty()将每个属性都转换为getter和setter，每个Vue组件实例都有一个对应的watcher实例，在组件初次渲染的时候会记录组件用到了哪些数据，当数据发生改变的时候，会触发setter方法，并通知所有依赖这个数据的watcher实例调用update方法去触发组件的compile渲染方法，进行渲染数据。 7.5 封装程度不同 封装程度，vue封装程度更高，内置多个指令和数据双向绑定。 react封装度比较低，适合扩展。 8. vue2和vue3的区别8.1 生命周期 vue3的生命周期在vue2生命周期名称前加上了“on”。 Vue3 在组合式API（Composition API，下面展开）中使用生命周期钩子时需要先引入，而 Vue2 在选项API（Options API）中可以直接调用生命周期钩子，如下所示。 1234567891011// vue3&lt;script setup&gt; import { onMounted } from 'vue'; // 使用前需引入生命周期钩子onMounted(() =&gt; { // ...});// 可将不同的逻辑拆开成多个onMounted，依然按顺序执行，不会被覆盖onMounted(() =&gt; { // ...});&lt;/script&gt; 12345678// vue2&lt;script&gt; export default { mounted() { // 直接调用生命周期钩子 // ... }, }&lt;/script&gt; 8.2 多根节点 vue2中，在模板中如果使用多个根节点时会报错。 vue3中，支持多个根节点，也就是 fragment。 8.3 Composition API Vue2 是选项API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。 Vue3 组合式API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。 8.4 异步组件Suspense Vue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。 使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态。 123456789101112&lt;template&gt; &lt;suspense&gt; &lt;template #default&gt; &lt;List /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt; Loading... &lt;/div&gt; &lt;/template&gt; &lt;/suspense&gt;&lt;/template&gt; 在 List 组件（有可能是异步组件，也有可能是组件内部处理逻辑或查找操作过多导致加载过慢等）未加载完成前，显示 Loading…（即 fallback 插槽内容），加载完成时显示自身（即 default 插槽内容）。 8.5 TeleportVue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗。 123456&lt;button @click=&quot;dialogVisible = true&quot;&gt;显示弹窗&lt;/button&gt;&lt;teleport to=&quot;body&quot;&gt; &lt;div class=&quot;dialog&quot; v-if=&quot;dialogVisible&quot;&gt; 我是弹窗，我直接移动到了body标签下 &lt;/div&gt;&lt;/teleport&gt; 8.6 响应式原理Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。 那 Vue3 为何会抛弃它呢？那肯定是因为它存在某些局限性。 主要原因：无法监听对象或数组新增、删除的元素。 局限性： (1)、对象/数组的新增、删除 (2)、监测 .length 修改 (3)、Map、Set、WeakMap、WeakSet 的支持","link":"/blog/2024/04/21/Vue%E7%AC%94%E8%AE%B0/"},{"title":"mac系统配置切换不同node版本","text":"1. 安装n使用npm全局安装n 1sudo npm install -g n 验证是否安装成功 1n -V 2. 安装和切换node版本列出所有node版本 1n ls 安装node 1sudo n xx.xx.x xx.xx.x是要安装的版本号 如果需要删除某个版本，执行以下命令 1n rm xx.xx.x 切换node版本，输入命令后上下键选择确认 1n","link":"/blog/2024/04/08/mac%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8Cnode%E7%89%88%E6%9C%AC/"},{"title":"使用Hexo在github上搭建博客","text":"1. 安装cnpm打开终端执行以下命令： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 检查cnpm是否安装成功： 1cnpm -v 如果输出版本号就是安装成功了。 2. 安装hexo和初始化博客2.1 安装hexo在终端执行以下命令安装hexo： 1cnpm install hexo-cli -g 2.2 初始化博客创建一个放置博客的文件夹，然后打开终端cd到这个文件夹路径，并执行： 1hexo init 可能会有报错，不用管 然后执行： 1sudo cnpm install 最后执行下面的命令可以预览博客页面： 1hexo s 3. 更换主题3.1 下载主题hexo的所有主题都在下面这个地址： 1https://hexo.io/themes/ 我们可以选择一个自己喜欢的主题，打开项目地址，点击“code”，复制HTTPS链接 在打开终端进入到博客目录，执行以下命令： 1git clone 复制的地址 themes/主题名字 上面的命令会克隆主题到themes文件夹下，并将克隆下的主题文件夹重命名为“主题名字” 3.2 配置主题在themes主题文件夹里的_config.yml是主题的配置文件 在这里面可以修改头像、背景等等 3.3 修改配置文件博客目录中的_config.yml是hexo的配置文件 在配置文件中找到themes，把主题名字修改为克隆下来的主题文件夹的名字 并且，在配置文件里可以设置语言、作者名称等等 3.4 预览主题打开终端进入博客目录，执行以下命令： 1hexo s 复制链接到浏览器粘贴打开，就可以看到修改主题后的博客页面 4. 写文章打开终端进入博客目录，执行以下命令创建新的文章： 1hexo new &quot;文章名称&quot; 这时候会在博客目录下的source-&gt;_posts下产生一个“文章名称.md”文件，我们可以使用Typora进行编辑 5. 部署博客首先需要在github上新建一个仓库用于存放博客 接下来，创建一个密钥，打开终端输入以下命令： 1ssh-keygen -t rsa -C “你的邮箱“ 然后执行以下命令进行查看，如果之前已经创建过密钥了，可以直接查看： 1cat ~/.ssh/id_rsa.pub 这时候会输出密钥，复制下来 点击github的头像，选择“Settings”，点击“SSH and GPG keys”新增密钥 粘贴密钥并保存 打开终端，执行以下命令： 1ssh -T git@github.com 会提示你下面这个，输入yes回车就行了 1Are you sure you want to continue connecting (yes/no/[fingerprint])? 打开项目，复制git开头的地址 打开博客目录下的_config.yml文件进行配置 1234deploy: type: git repo: 你复制的地址 branch: main 打开终端进入博客根目录，分别执行以下命令： 12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot; 然后安装上传插件： 1sudo cnpm install hexo-deployer-git --save 执行以下命令上传博客： 1hexo g -d 打开项目，点击Settings，选择main分支，之后就会得到一个博客的链接，通过链接就可以在线打开博客了 6. 更新博客每次写博客的时候，打开终端进入博客根目录，然后创建新的文章 1hexo new &quot;文章名称&quot; 文章写好后，一次执行以下命令，将改动同步到github上 123hexo cleanhexo ghexo d hexo clean：清空public目录下的静态网页文件 hexo g：生成静态网页文件到public目录下 hexo d：将博客部署到github 7. 删除文章1、删除文件夹source/_posts下目标文章markdown文件2、删除.deploy_git文件夹3、执行hexo clean后，再执行hexo g，hexo d 即可。 8. 使用github搭建图床8.1 创建新仓库 8.2 生成token点击头像的“Settings”选项卡，点击最下面的“Developer settings” 点击“Tokens(classic)”，创建token，并勾选repo 创建完以后，就会出现一串Token字符串，把这个Token复制保存下来 8.3 使用PicGo实现图片上传使用山东大学镜像网站进行下载 https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/ 下载好后进行安装，如果是mac电脑安装好后可能出现文件损坏打不开的问题，这时候只需要在终端执行以下命令就可以打开了 1sudo xattr -d com.apple.quarantine &quot;/Applications/PicGo.app&quot; 配置一下PicGo，将上一步生成的token粘贴到这里 然后是自定义域名，我们可以用一个免费的加速域名作为我们自定义域名 比如： 1https://cdn.jsdelivr.net/gh/ +你的账户名+你的仓库名@你的分支名 所以我的域名就是： 1https://cdn.jsdelivr.net/gh/zwx1123/blogPic@main 参考： https://www.cnblogs.com/huanhao/p/hexobase.html#%E5%9F%BA%E7%A1%80%E7%AF%87%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E4%B8%80 https://blog.csdn.net/xdnxl/article/details/129466060","link":"/blog/2024/04/07/%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"react-router-cache-route的使用","text":"1. 介绍搭配 react-router 工作的、带缓存功能的路由组件，类似于 Vue 中的 keep-alive 功能 React v15+ React-Router v4+ 2. 问题场景使用 Route 时，路由对应的组件在前进或后退无法被缓存，导致了 数据和行为的丢失 例如：列表页滚动到底部后，点击跳转到详情页，返回后会回到列表页顶部，丢失了滚动位置和数据的记录 3. 安装123npm install react-router-cache-route --save# oryarn add react-router-cache-route 4. 使用使用 CacheRoute 替换 Route 使用 CacheSwitch 替换 Switch（因为 Switch 组件只保留第一个匹配状态的路由，卸载掉其他路由） 123456789101112131415161718import React from 'react'import { HashRouter as Router, Route } from 'react-router-dom'import CacheRoute, { CacheSwitch } from 'react-router-cache-route'import List from './views/List'import Item from './views/Item'const App = () =&gt; ( &lt;Router&gt; &lt;CacheSwitch&gt; &lt;CacheRoute exact path=&quot;/list&quot; component={List} /&gt; &lt;Route exact path=&quot;/item/:id&quot; component={Item} /&gt; &lt;Route render={() =&gt; &lt;div&gt;404 未找到页面&lt;/div&gt;} /&gt; &lt;/CacheSwitch&gt; &lt;/Router&gt;)export default App 5. 生命周期5.1 Hooks使用 useDidCache 和 useDidRecover 来对应 被缓存 和 被恢复 两种生命周期 123456789101112131415161718192021import { useDidCache, useDidRecover } from 'react-router-cache-route'export default function List() { useDidCache(() =&gt; { console.log('List cached 1') }) // support multiple effect useDidCache(() =&gt; { console.log('List cached 2') }) useDidRecover(() =&gt; { console.log('List recovered') }) return ( // ... )} 5.2 Class组件使用 CacheRoute 的组件将会得到一个名为 cacheLifecycles 的属性，里面包含两个额外生命周期的注入函数 didCache 和 didRecover，分别在组件 被缓存 和 被恢复 时触发 123456789101112131415161718192021222324import React, { Component } from 'react'export default class List extends Component { constructor(props) { super(props) props.cacheLifecycles.didCache(this.componentDidCache) props.cacheLifecycles.didRecover(this.componentDidRecover) } componentDidCache = () =&gt; { console.log('List cached') } componentDidRecover = () =&gt; { console.log('List recovered') } render() { return ( ... ) }} 6. 手动清除缓存使用 cacheKey 和 dropByCacheKey 函数来手动控制缓存 1234567891011import CacheRoute, { dropByCacheKey, getCachingKeys } from 'react-router-cache-route'...&lt;CacheRoute ... cacheKey=&quot;MyComponent&quot; /&gt;...console.log(getCachingKeys()) // 如果 `cacheKey` prop 为 'MyComponent' 的缓存路由已处于缓存状态，将得到 ['MyComponent']...dropByCacheKey('MyComponent')... 7. 清空缓存使用 clearCache 函数来清空缓存 123import { clearCache } from 'react-router-cache-route'clearCache() 转载——官方文档：https://github.com/CJY0208/react-router-cache-route/blob/master/README_CN.md","link":"/blog/2024/08/16/react-router-cache-route%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"前端性能优化笔记","text":"1. 如何减少首屏加载时间1.1 减小入口文件体积常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加。 在vue-router配置路由的时候，采用动态加载路由的形式 12345678routes:[ { path: 'Blogs', name: 'ShowBlogs', component: () =&gt; import('./components/ShowBlogs.vue') }, {...}] 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件。 1.2 UI框架按需加载在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库。 12import ElementUI from 'element-ui'Vue.use(ElementUI) 但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用。 1234import { Button, Input, Pagination, Table, TableColumn, MessageBox } from 'element-ui';Vue.use(Button)Vue.use(Input)Vue.use(Pagination) 1.3 图片资源压缩图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素。 对于所有的图片资源，我们可以进行适当的压缩。 对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。 1.4 DNS解析优化如果一个页面中有很多外部资源，例如JavaScript、CSS、或者图片等资源，每次解析页面的时候都需要将这些资源的域名解析成IP地址。 同步解析： 异步解析： 我们可以使用link元素，在页面前面对资源的域名进行异步解析： 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.coffee.com&quot;/&gt; 在实际项目中可以这么做： 编写一个自动生成link标签的dns-prefetch.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const fs = require('fs');const path = require('patch');const { parse } = require('node-html-parser');const { glob } = require('glob');const urlRegex = require('url-regex');// 获取外部链接的正则表达式const urlPattern = /(https?:\\/\\/[^/]*)/i;const urls = new Set();// 遍历dist目录中的所有HTML、js、css文件async function searchDomain() { const files = await glob('dist/**/*.{html,css,js}'); for (const file of files) { // 读取文件内容 const source = fs.readFileSync(file, 'utf-8'); // 匹配链接 const matches = source.match(urlRegex({strict: true})); if (matches) { matches.forEach((url) =&gt; { const match = url.match(urlPattern); if (match &amp;&amp; match[1]) { // 将域名加入到set中 urls.add(match[1]); } }); } }}// 将域名转换成link元素async function insertLinks() { const files = await glob('dist/**/*.html'); const links = [...urls] .map((url) =&gt; `&lt;link rel=&quot;dns-prefetch&quot; href=&quot;${url}&quot;/&gt;`) .join('\\n'); for (const file of files) { const html = fs.readFileSync(file, 'utf-8'); // 将html字符串解析成DOM树 const root = parse(html); const head = root.querySelector('head'); // 在&lt;head&gt;标签中加入预取链接 head.insertAdjacentHTML('afterbegin', links); fs.writeFileSync(file, root.toString()); }}async function main() { await searchDomain(); await insertLinks();}main(); 在package.json打包文件中进行配置： ![截屏2023-10-24 10.08.21](/Users/zhangwenxiao/Documents/笔记/img/截屏2023-10-24 10.08.21.png) 这样在npm run build构建项目的时候就会自动运行写好的函数，提取出外部链接构建link标签，进行域名的异步解析。 2. 重排与重绘2.1 页面生成的过程 HTML 被 HTML 解析器解析成 DOM 树 CSS 被 CSS 解析器解析成 CSSOM 树 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点 将布局绘制(paint)在屏幕上，显示出整个页面 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染 2.2 渲染在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。 2.3 重排（回流）&gt; 重绘单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。也就是说：重绘不一定导致重排，但重排一定会导致重绘。 2.4 重排 (reflow)概念当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。重排也叫回流，简单的说就是重新生成布局，重新排列元素。 发生重排的情况 页面初始渲染，这是开销最大的一次重排 添加/删除可见的DOM元素 改变元素位置 改变元素尺寸，比如边距、填充、边框、宽度和高度等 改变元素内容，比如文字数量，图片大小等 改变元素字体大小 改变浏览器窗口尺寸，比如resize事件发生时 激活CSS伪类（例如：:hover） 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。 重排影响的范围由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种： 全局范围：从根节点html开始对整个渲染树进行重新布局。 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局 2.5 重绘 (repaints)概念当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。 2.6 如何减少重排和重绘 避免设置多层内联样式 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素 避免使用table布局，一个小的改动可能会使整个table进行重新布局 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写 浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次回流、重绘变成一次回流重绘。 3. 防抖函数防抖是指在事件被触发n秒后再执行，如果在这n秒内事件又被触发，则重新计时 3.1 非立即执行版123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;button onclick=&quot;btnClick()&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function debounce(fn, wait) { let timer = null; return function() { const context = this; const args = arguments; // 如果此时存在计时器，则取消之前的计时器重新计时 if(timer) { clearTimeout(timer); timer = null; } // 设置计时器，setTimeout返回值 timeoutID 是一个正整数，表示由 setTimeout() 调用创建的定时器的编号。 timer = setTimeout(() =&gt; { fn.apply(context, args); }, wait); } } function handler() { console.log('点击按钮'); } const btnClick = debounce(handler, 1000); &lt;/script&gt; 3.2 立即执行版12345678910111213141516171819202122232425262728293031&lt;div&gt; &lt;button onclick=&quot;btnClick()&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function debounce(fn, wait) { let timer = null; return function() { const context = this; const args = arguments; const callNow = !timer; if(timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { timer = null; }, wait); if (callNow) fn.apply(context, args); } } function handler() { console.log('点击按钮'); } const btnClick = debounce(handler, 1000); &lt;/script&gt; 4. 节流函数节流是指规定的时间内，只能触发一次这个事件，如果在同一个规定时间内，事件被触发多次，只有一次能生效。 12345678910111213141516171819202122232425&lt;div&gt; &lt;button onclick=&quot;btnClick()&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script&gt; function throttle(fn, delay) { let curTime = Date.now(); return function() { const context = this; const args = arguments; const nowTime = Date.now(); if (nowTime - curTime &gt;= delay) { curTime = Date.now(); fn.apply(context, args); } } } function handler() { console.log('点击按钮'); } const btnClick = throttle(handler, 1000);&lt;/script&gt;","link":"/blog/2024/04/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"title":"变量提升与暂时性死区","text":"1. 变量提升使用var申明变量的时候，不管变量的申明写在哪里，最后都会被提升到顶端去。因此，我们可以先使用变量，在申明变量，却不会报错，只会输出undefined。 12console.log(num) // undefinedvar num = 1; 在函数中也是一样的，在函数内部申明的变量会被提升到函数作用域的顶端。 1234function getNum() { console.log(num); // undefined var num = 1;} 事实上，JS也是有编译阶段的，它和传统语言的区别在于，JS不会早早地把编译工作做完，而是一边编译一边执行。在这个短暂的编译阶段里，JS 引擎会搜集所有的变量声明，并且提前让声明生效。至于剩下的语句，则需要等到执行阶段、等到执行到具体的某一句的时候才会生效。这就是变量提升背后的机制。 2. 暂时性死区按理说下面这段代码会正常运行，因为运行到me = 'lee';的时候me已经申明了，但却报错了。 12345var me = 'icon';{ me = 'lee'; let me;} 这是因为 ES6 中有明确的规定：如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。假如我们尝试在声明前去使用这类变量，就会报错，这就是“暂时性死区”。这时候去掉me = 'lee';就可以正常运行了。","link":"/blog/2024/04/22/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA/"},{"title":"排序算法","text":"1. 插入类排序1.1 直接插入排序 1234567891011121314151617class Solution { public void insertSort(int[] arr, int n) { int tmp; for (int i = 1; i &lt; n; i++) { // 将待插入的关键字暂存于tmp中 tmp = arr[i]; int j = i - 1; // 依次从待排关键字之前的关键字进行扫描 while (j &gt;= 0 &amp;&amp; tmp &lt; arr[j]) { arr[j + 1] = arr[j]; --j; } // 找到插入位置 arr[j + 1] = tmp; } }} 时间复杂度 最坏情况：$O(n^2)$ 最好情况：$O(n)$ 平均时间复杂度：$O(n^2)$ 2. 交换类排序2.1 冒泡排序123456789101112131415161718192021class Solution { public void bubbleSort(int[] arr, int n) { boolean flag; int tmp; for (int i = n - 1; i &gt;= 1; i--) { // 用flag标记本趟排序是否发生了交换 flag = false; for (int j = 1; j &lt;= i; j++) { if (arr[j - 1] &gt; arr[j]) { tmp = arr[j]; arr[j] = arr[j -1]; arr[j - 1] = tmp; flag = true; } } if (!flag) { return; } } }} 时间复杂度 最坏情况：$O(n^2)$ 最好情况：$O(n)$ 平均时间复杂度：$O(n^2)$ 2.2 快速排序1234567891011121314151617181920212223242526272829303132class Solution { public void quickSort(int[] arr, int low, int high) { // 对从arr[low]到arr[high]的关键字进行排序 int tmp; int i = low, j = high; if (low &lt; high) { tmp = arr[low]; // 将小于tmp的数放左边，将大于tmp的数放右边 while (i &lt; j) { // 从右往左扫描，找到一个小于tmp的数 while (i &lt; j &amp;&amp; arr[j] &gt;= tmp) { --j; } if (i &lt; j) { arr[i] = arr[j]; ++i; } // 从左往右扫描，找到一个大于tmp的数 while (i &lt; j &amp;&amp; arr[i] &lt; tmp) { ++i; } if (i &lt; j) { arr[j] = arr[i]; --j; } arr[i] = tmp; quickSort(arr, low, i - 1); quickSort(arr, i + 1, high); } } }} 时间复杂度 最坏情况：$O(n^2)$ 最好情况：$O(nlog_2n)$ 平均时间复杂度：$O(nlog_2n)$ 待排序列越接近无序，算法效率越高。 3. 选择类排序3.1 简单选择排序12345678910111213141516class Solution { public void selectSort(int[] arr, int n) { int tmp; for (int i = 0; i &lt; n; i++) { int k = i; for (int j = i + 1; j &lt; n; ++j) { if (arr[k] &gt; arr[j]) { k = j; } } tmp = arr[i]; arr[i] = arr[k]; arr[k] = tmp; } }} 时间复杂度：$O(n^2)$","link":"/blog/2024/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"浏览器原理笔记","text":"1. 事件循环1.1 为什么单线程却可以异步事件循环，是浏览器或Node解决单线程运行时不会阻塞的一种机制。 JavaScript的确是一门单线程语言，但是浏览器UI是多线程的，异步任务借助浏览器的线程和JavaScript的执行机制实现。 例如，setTimeout就借助浏览器定时器触发线程的计时功能来实现。 1.2 事件循环的执行过程 代码开始执行，创建一个全局调用栈，script作为宏任务执行 执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列 同步任务执行完毕，查看微任务队列 若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务) 若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空 1.3 微任务和宏任务的根本区别 微任务：指在当前任务执行结束后立即执行的任务，它可以看作是在当前任务的“尾巴”添加的任务。 常见的微任务包括：Promise、async/await 宏任务：指需要排队等待 JavaScript 引擎空闲时才能执行的任务。 常见的宏任务包括：setTimeout、setInterval、Ajax、DOM事件 JavaScript 引擎会先执行当前任务中的所有微任务，然后再执行宏任务队列中的第一个任务。这个过程会不断重复，直到宏任务队列中的任务被全部执行完毕。 2. cookie和session的区别2.1 存储位置不同cookie的数据信息存放在本地。session的数据信息存放在服务器上。 2.2 存储容量大小不同cookie存储的容量较小，一般&lt;=4KB。session存储容量大小没有限制(但是为了服务器性能考虑，一般不能存放太多数据)。 2.3 存储有效期不同cookie可以长期存储，只要不超过设置的过期时间，可以一直存储。session在超过一定的操作时间(通常为30分钟)后会失效，但是当关闭浏览器时，为了保护用户信息，会自动调用session.invalidate()方法，该方法会清除掉session中的信息。 2.4 安全性不同cookie存储在客户端，所以可以分析存放在本地的cookie并进行cookie欺骗，安全性较低。session存储在服务器上，不存在敏感信息泄漏的风险，安全性较高。 2.5 域支持范围不同cookie支持跨域名访问。例如，所有a.com的cookie在a.com下都能用。session不支持跨域名访问。例如，www.a.com的session在api.a.com下不能用。 2.6 对服务器压力不同cookie保存在客户端，不占用服务器资源。session是保存在服务器端，每个用户都会产生一个session，session过多的时候会消耗服务器资源，所以大型网站会有专门的session服务器。 2.7 存储的数据类型不同cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。 3. 哪些情况会造成内存泄漏3.1 内存泄漏内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 3.2 意外的全局变量在js中，一个未声明变量的使用，会在全局对象中创建一个新的变量；在浏览器环境下，全局对象就是window 1234567function foo(){ a=&quot;test&quot;}//上面的写法等同于function foo(){ window.a =&quot;test&quot;} 3.3 计时器和回调函数定时器setInterval或者setTimeout在不需要使用的时候，没有被clear，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。解决方式：当不需要interval或者timeout的时候，调用clearInterval或者clearTimeout 3.4 脱离DOM的引用获取一个DOM元素的引用， 而后面这个元素被删除了，由于一直保留了对这个元素的引用，所以它也无法被回收。 4. 对事件委托的理解4.1 事件委托的概念事件委托的本质是利用了浏览器事件冒泡的机制。在冒泡阶段，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。 1234567891011121314&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot;&gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot;&gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot;&gt;item3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; document.getElementById(&quot;list&quot;).addEventListener(&quot;click&quot;, function (e) { const target = e.target; if (target.tagName === &quot;LI&quot; &amp;&amp; target.parentNode === this) console.log(target.innerHTML, '被点击'); }) &lt;/script&gt;&lt;/body&gt; 4.2 事件委托的特点减少内存消耗如果有一个列表，列表中有大量的列表项，需要在点击列表项的时候响应一个事件。如果给每个列表项都绑定一个函数，对内存消耗非常大。可以把点击事件绑定到父节点上。动态绑定事件如果列表项存在频繁更新的情况，就需要每一次在改变的时候都重新给新增的元素绑定事件，给即将删除的元素解绑事件。如果使用事件委托就不需要这么麻烦，因为事件是绑定在父元素上的，和目标元素的增减无关。 4.3 局限性focus、blur之类的事件没有冒泡机制，所以无法实现事件委托；mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此不适合于事件委托。事件委托也会影响页面性能，主要影响因素有： 元素中，绑定事件委托的次数 点击最底层元素，到绑定事件元素之间的DOM层数 5. XSS攻击5.1 反射型XSS 5.2 存储型XSS 5.3 DOM型XSS攻击示例 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM Based XSS Demo&lt;/title&gt; &lt;script&gt; function xsstest() { var str = document.getElementById(&quot;input&quot;).value; document.getElementById(&quot;output&quot;).innerHTML = &quot;&lt;img src='&quot;+str+&quot;'&gt;&lt;/img&gt;&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;output&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot; size=50 value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;submit&quot; onclick=&quot;xsstest()&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 在这段代码中，submit按钮的onclick事件调用了xsstest()函数。而在xsstest()中，修改了页面的DOM节点，通过innerHTML把一段用户数据当作HTML写入到页面中，造成了DOM Based XSS。","link":"/blog/2024/04/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"},{"title":"解决kex_exchange_identification报错问题","text":"1. 问题排查在某一次写完博客使用hexo d部署的时候出现了kex_exchange_identification: Connection closed by remote host的错误，应该是使用SSH连接github的时候出现了错误。 可以使用以下命令验证是否是SSH出现了问题： 1ssh -T git@github.com 果然还是出现了kex_exchange_identification: Connection closed by remote host的错误。 这可能是由于多种原因造成，下面是一些可能的解决方案： 检查SSH密钥：确保你的SSH密钥是正确的，并且已经添加到GitHub的账户设置中。你可以在GitHub的账户设置中查看和添加SSH密钥。 检查SSH配置文件：检查你的SSH配置文件（通常位于~/.ssh/config）是否正确配置。确保没有配置错误，例如错误的端口号或主机名。 更新SSH密钥：如果你的SSH密钥已经过期或已被替换，尝试更新SSH密钥并重新添加到GitHub账户中。 检查网络连接：确保你的网络连接正常，并且没有被防火墙或代理服务器阻止。尝试使用其他网络连接或检查防火墙设置。 更新Git版本：如果你使用的是较旧的Git版本，可能会遇到与SSH连接相关的问题。尝试更新Git到最新版本，并重新尝试连接。 检查SSH代理：如果你使用了SSH代理，确保代理设置正确，并且代理服务器正常运行。 重启SSH服务：在某些情况下，重启SSH服务可能有助于解决问题。 清除SSH缓存：有时候，SSH缓存可能导致连接问题。你可以尝试清除SSH缓存，并重新连接。 2. 解决方法尝试了多种办法无果后，最后通过HTTPS端口使用SSH解决了问题。 首先测试是否可以通过HTTPS端口使用SSH，请运行以下SSH命令： 123$ ssh -T -p 443 git@ssh.github.com&gt; Hi USERNAME! You've successfully authenticated, but GitHub does not&gt; provide shell access. 如果可以，则覆盖 SSH 设置以强制任何与 GitHub.com 的连接通过该服务器和端口运行。要在 SSH 配置文件中设置此项，编辑文件~/.ssh/config。 进入~/.ssh/文件夹： 1cd ~/.ssh/ 编辑config文件： 1vim config 添加下面的代码： 1234Host github.comHostname ssh.github.comPort 443User git 按esc健退出编辑，并输入:wq保存并退出。 这时候可以通过再次连接到github.com测试配置是否生效： 123$ ssh -T git@github.com&gt; Hi USERNAME! You've successfully authenticated, but GitHub does not&gt; provide shell access. 切换到端口 443 后第一次与 GitHub 交互时，可能会收到一条警告消息，提示在 中未找到主机known_hosts，或者通过其他名称找到主机。 12345&gt; The authenticity of host '[ssh.github.com]:443 ([140.82.112.36]:443)' can't be established.&gt; ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.&gt; This host key is known by the following other names/addresses:&gt; ~/.ssh/known_hosts:32: github.com&gt; Are you sure you want to continue connecting (yes/no/[fingerprint])? 如果 SSH 指纹与 GitHub 发布的指纹之一匹配，则可以输入“yes”。 这时候就可以使用hexo d命令部署新写的文章了。 转载：https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port","link":"/blog/2024/08/16/%E8%A7%A3%E5%86%B3kex-exchange-identification%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"},{"title":"计算机网络笔记","text":"1. 单点登录的实现方式1.1 什么是单点登录单点登录（Single Sign On, SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。 举例来说，百度贴吧和百度地图是百度公司旗下的两个不同的应用系统，如果用户在百度贴吧登录过之后，当他访问百度地图时无需再次登录，那么就说明百度贴吧和百度地图之间实现了单点登录。 1.2 实现方式一：父域 CookieCookie 有一个特点，即父域中的 Cookie 被子域所共享，换言之，子域会自动继承父域中的Cookie。我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。总结：此种实现方式比较简单，但不支持跨主域名。 1.3 实现方式二：认证中心我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。 1.4 实现方式三：LocalStorage 跨域父域 Cookie 确实是一种不错的解决方案，但是不支持跨域。可以选择将 Token 保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。后端需要做的仅仅是在用户登录成功后，将 Token 放在响应体中传递给前端。在这样的场景下，单点登录完全可以在前端实现。前端拿到 Session ID （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中。总结：此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域。 2. token是否可以被拦截，获取登录状态 首先，Token 一般放在 Header 或者 Cookies 中，Http 是明文传输，Https 是密文传输。可以一定程度防止Token 截获。 第二，Token 一般会和 Ip，MAC地址，或者 DeviceID 进行绑定。如果服务端检测这些发生了变化，可以将 Token 失效让用户重新登录。 第三，Token 可以加密，例如AES对称加密，客户端与服务端先交换对称秘钥之后用对称秘钥将 Token + 当前时间戳 对称加密后发往服务端解密验证 Token 和时间戳都有效。或者直接通过 RSA 公钥加密。增加了截取成本。 第四，敏感操作一般要求二次安全验证，例如支付的时候，需要支付密码，或者验证手机短信验证码等等。 3. HTTPS通信过程 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口) 采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书 (当然了是要钱的，安全级别越高价格越贵)。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息、使用者（公司）信息和证书有效期、签名算法等（Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息） 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。 服务器在收到随机码 KEY 之后会使用私钥B将其解密。 经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题（公钥加密，私钥解密），接下来就可以用对称加密进行通信了。 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。 接下来双方使用对称加密进行传输所有数据。","link":"/blog/2024/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python","slug":"Python","link":"/blog/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","link":"/blog/tags/Anaconda/"},{"name":"CSS","slug":"CSS","link":"/blog/tags/CSS/"},{"name":"前端开发","slug":"前端开发","link":"/blog/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"HTML","slug":"HTML","link":"/blog/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","link":"/blog/tags/JavaScript/"},{"name":"React","slug":"React","link":"/blog/tags/React/"},{"name":"Vue","slug":"Vue","link":"/blog/tags/Vue/"},{"name":"mac系统","slug":"mac系统","link":"/blog/tags/mac%E7%B3%BB%E7%BB%9F/"},{"name":"node","slug":"node","link":"/blog/tags/node/"},{"name":"hexo","slug":"hexo","link":"/blog/tags/hexo/"},{"name":"Router","slug":"Router","link":"/blog/tags/Router/"},{"name":"性能优化","slug":"性能优化","link":"/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"ES6","slug":"ES6","link":"/blog/tags/ES6/"},{"name":"排序算法","slug":"排序算法","link":"/blog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"浏览器原理","slug":"浏览器原理","link":"/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"计算机网络","slug":"计算机网络","link":"/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"配置","slug":"配置","link":"/blog/categories/%E9%85%8D%E7%BD%AE/"},{"name":"前端笔记","slug":"前端笔记","link":"/blog/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/blog/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"tags","text":"","link":"/blog/tags/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"}]}